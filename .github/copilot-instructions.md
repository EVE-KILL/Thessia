# Copilot Instructions

## Project Overview

This project uses:

-   **Nuxt (Vue 3 & Nitro)** for frontend and backend.
-   **Nuxt/UI** for UI components. (AVOID Using Nuxt/UI components as much as possible, use the components located in the `/app/components` folder instead (like instead of `UTable` use `Table`from `/app/components/common/Table.vue`))
-   **MongoDB (via Mongoose)** for data storage.
-   **Redis (via ioredis)** for caching.
-   **BullMQ** for job processing.

## Architecture Overview

**Full-Stack EVE Online Killboard** with unique build system:

-   **Frontend**: Vue 3 + custom components + TypeScript
-   **Backend**: Nitro (Nuxt server) + standalone CLI/Cron/Queue binaries
-   **Critical Build System**: Auto-generates loader files (`build.ts`) for standalone binaries

### Auto-Generated Loaders

-   `console/.loader.ts` - CLI commands from `/console/*.ts`
-   `cron/.loader.ts` - Cron jobs from `/cron/*.ts`
-   `queue/.loader.ts` - Queue processors from `/queue/*.ts`

**⚠️ Never manually edit .loader.ts files** - they're auto-generated by `generateAllLoaders()`nstructions

## Project Overview

This project uses:

-   **Nuxt (Vue 3 & Nitro)** for frontend and backend.
-   **Nuxt/UI** for UI components. (AVOID Using Nuxt/UI components as much as possible, use the components located in the `/app/components` folder instead (like instead of `UTable` use `Table`from `/app/components/common/Table.vue`))
-   **MongoDB (via Mongoose)** for data storage.
-   **Redis (via ioredis)** for caching.
-   **BullMQ** for job processing.

## Project Structure

-   **API:** `/server/api`
-   **Nitro Routes:** `/server/routes`
-   **Vue Pages:** `/app/pages`
-   **MongoDB Models:** `/server/models`
-   **Queues:** `/queue` (note: root level, not `/src/queue`)
-   **Cron Jobs:** `/cron`
-   **Console Commands:** `/console`
-   **i18n Files:** `/i18n/locales`

## Code Conventions

-   Follow **TypeScript** best practices.
-   Structure Vue components modularly.
-   Use composition API with `<script setup lang="ts">` syntax.
-   Prefer typed refs and reactive objects.
-   Use kebab-case for file names and component names.
-   Use PascalCase for component imports and registrations.
-   Use camelCase for variables, functions, and properties.
-   Use UPPER_SNAKE_CASE for constants.
-   Include JSDoc comments for public functions and types.
-   Organize imports by: built-in modules, external modules, internal modules.

## Internationalization

-   Use `t('key')` in composables with `useI18n()` hook
-   Organize translations by feature area
-   Include all user-facing strings in english translation, located at `i18n/locales/en.json`
-   Support locale fallbacks

## Icons

-   Use **Lucide Icons** for all icons.
-   Use **Simple Icons** for SVG icons.
-   Use the **common Image component** for EVE Online related images (character portraits, corporation logos, alliance logos, item icons, ship renders, etc.)
    -   Use `type="character"` for character portraits
    -   Use `type="corporation"` for corporation logos
    -   Use `type="alliance"` for alliance logos
    -   Use `type="type-icon"` for item/ship icons
    -   Use `type="type-render"` for ship renders
    -   Pass the appropriate ID and size props

## Currency and ISK Formatting

-   Use the **formatIsk utility** for displaying ISK values in the UI
-   The utility automatically formats large numbers with B/M/K suffixes
-   Import is automatic due to auto-imports configuration
-   Use regular number inputs for form fields, but display formatted values in tables and readonly contexts

## CSS and Styling

-   **NEVER use Tailwind CSS `@apply` directives** - they are not supported in this project
-   Use regular CSS properties instead of `@apply` directives
-   Use `:global(.dark)` selectors for dark mode styling instead of `dark:` prefixes
-   Structure CSS with proper classes and regular CSS syntax
-   Use CSS custom properties for theming when needed
-   Prefer scoped styles with `<style scoped>` in Vue components

Example of **INCORRECT** styling:

```css
.my-class {
    @apply flex items-center gap-2 px-4 py-2; /* ❌ DON'T DO THIS */
}
```

Example of **CORRECT** styling:

```css
.my-class {
    display: flex; /* ✅ Use regular CSS */
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
}

:global(.dark) .my-class {
    background-color: #374151; /* ✅ Dark mode with :global */
}
```

## Documentation

The project includes comprehensive documentation in the `/docs` folder that should be referenced for implementation guidance:

-   **Frontend Documentation**: `/docs/frontend/` - Contains implementation examples and patterns
    -   **Search Components**: `/docs/frontend/search-component-examples.md` - Complete implementation guide for search functionality with standardized styling and API patterns
    -   Component usage examples, styling guidelines, and best practices
-   **Backend Documentation**: `/docs/backend/` - API design patterns and database schemas
-   **Installation & Development**: `/docs/installation/` and `/docs/development/` - Setup and development workflows
-   **API Documentation**: `/docs/api/` - Endpoint specifications and usage examples

**Always check the documentation before implementing new features** - it contains:

-   Proven implementation patterns
-   Standardized styling guidelines
-   API integration examples
-   Troubleshooting guides
-   Best practices and conventions

When implementing components like search functionality, data tables, forms, or other common patterns, reference the relevant documentation to ensure consistency with established patterns and avoid reinventing solutions.

## Nitro API Best Practices

-   **Query Parameters**: Use `getQuery(event)` to access URL query parameters (e.g., `?filters=...&page=1`)
-   **Route Parameters**: Use `event.context.params?.id` to access dynamic route parameters (e.g., `/killmail/[id]/esi.get.ts`)
-   **Cache Keys**: In `defineCachedEventHandler`, use the `getKey: (event) => { ... }` function with `getQuery(event)` for query params and `event.context.params` for route params
-   **Never** manually parse URLs with `url.parse(event.node.req.url)` - use the proper Nitro helpers instead

## Data Fetching Best Practices

-   **Prefer `useFetch` over `useAsyncData`** for better SSR/client coordination and hydration reliability
-   **Use `server: true, lazy: false`** for critical content that needs SSR (pages, SEO content)
-   **Use `server: false`** for user-triggered actions or client-side only data fetching
-   **Always provide `default()` fallback** to prevent hydration mismatches and improve reliability
-   **Use the `pending` state** from useFetch instead of manual loading state management
-   **Structure templates to handle loading states** with skeleton components during `pending`
-   **Use computed API endpoints** that react to filter changes for dynamic data fetching
-   **Handle errors** with the `error` state returned from useFetch
-   **Use `refresh()` function** for manual data refetching instead of re-calling $fetch
-   **Never use useFetch inside functions** - for on-demand requests use `$fetch` directly

### SSR-Optimized Pattern (for pages, components):

```vue
<template>
    <div>
        <!-- Show skeleton while loading -->
        <template v-if="pending">
            <USkeleton class="h-8 w-full mb-4" />
            <USkeleton class="h-4 w-3/4" />
        </template>

        <!-- Show content when loaded -->
        <div v-else-if="data">
            <h1>{{ data.title }}</h1>
            <p>{{ data.description }}</p>
        </div>

        <!-- Show error state -->
        <div v-else-if="error">Error loading content: {{ error }}</div>
    </div>
</template>

<script setup>
const { data, pending, error, refresh } = await useFetch("/api/content", {
    key: "content-data",
    server: true, // Enable SSR for SEO
    lazy: false, // Don't delay initial render
    default: () => null, // Fallback for SSR failures
});
</script>
```

### Client-Side Only Pattern (for user actions):

```vue
<script setup>
// For reactive data fetching based on user input/filters
const { data, pending, error } = await useFetch("/api/search", {
    query: searchParams, // Reactive query params
    key: "search-results",
    server: false, // Client-side only
    default: () => [], // Empty array fallback
    watch: [searchParams], // Refetch when params change
});
</script>
```

### On-Demand Pattern (for form submissions, actions):

```vue
<script setup>
// For user-triggered actions, use $fetch directly
const isLoading = ref(false);
const error = ref(null);

const handleSubmit = async () => {
    try {
        isLoading.value = true;
        error.value = null;

        const result = await $fetch("/api/submit", {
            method: "POST",
            body: formData.value,
        });

        // Handle success
        await navigateTo(`/success/${result.id}`);
    } catch (err) {
        error.value = err.message;
    } finally {
        isLoading.value = false;
    }
};
</script>
```

## Security and CSP Compliance

-   **Content Security Policy**: The project has strict CSP headers configured in `nuxt.config.ts`
-   **External Website Calls**: When adding external API calls, image sources, or script sources to frontend code (`/app`), verify they are allowed in the CSP configuration
-   **Image Sources**: The CSP `img-src` policy allows:
    -   EVE Online assets: `images.evetech.net`, `images.eve-kill.com`
    -   Reddit images: `i.redd.it`, `preview.redd.it`
    -   Imgur images: `i.imgur.com`
    -   **All HTTPS images**: `https:` - This allows user-generated content from Imgur, Giphy, Tenor, and any other HTTPS image hosting service
-   **User-Generated Content**: The KillComments component allows users to post images from various sources (Imgur, Giphy, Tenor, or any HTTPS URL), which is supported by the current CSP policy
-   **Allowed Domains**: Currently approved domains include:
    -   Images: `images.evetech.net`, `images.eve-kill.com`, `i.redd.it`, `i.imgur.com`, `preview.redd.it`, and **all HTTPS sources**
    -   Connections: `images.evetech.net`, WebSocket connections to `eve-kill.com`
    -   Scripts: Cloudflare challenges, blob URLs for web workers
-   **Adding New Domains**: If new external domains are needed for non-image resources, update the CSP configuration in `nuxt.config.ts` under `security.headers.contentSecurityPolicy`
-   **CSP Violations**: Any external resource not in the CSP will be blocked by the browser in production

## Database Architecture

### MongoDB Schema Patterns

All models follow consistent patterns:

```typescript
// Mongoose schemas with sparse indexes for optional fields
schema.index({ field: 1 }, { sparse: true });

// Automatic _id removal in JSON output
toJSON: {
    transform: (_doc, ret) => {
        delete ret._id;
        delete ret.__v;
    };
}

// Timestamps enabled on all collections
timestamps: true;
```

### Performance Best Practices

-   Always use bulk operations for database writes: `Model.bulkWrite(operations)`
-   Use sparse indexes on optional fields
-   Consider MongoDB query performance, especially with large collections

## Queue System (BullMQ + Redis)

### Queue Processing Pattern

Background jobs use standardized worker patterns:

```typescript
// queue/processKillmails.ts
createWorker(
    "killmail",
    async (job: Job) => {
        const { killmailId, killmailHash } = job.data;
        await processKillmail(killmailId, killmailHash);
    },
    { concurrency: 5 }
);
```

Always use bulk job additions for performance: `queue.addBulk(jobs)`

## Development Workflows

### Console Commands

```bash
bun run console.ts <command>  # CLI commands
bun run cron.ts <job>         # Manual cron execution
bun run queue.ts <processor>  # Queue processors
bun run build:loaders         # Regenerate loader files
```

## Copilot-Specific Instructions

-   Follow project structure and conventions.
-   Use `useFetch` for API calls (preferred for reliability and SSR coordination)
-   Handle errors with try-catch blocks.
-   Use `cliLogger` for logging. (cliLogger.info('message') for example)
-   Implement proper TypeScript typing for all functions and variables.
-   Follow the single responsibility principle.
-   Utilize existing composables and utilities before creating new ones.
-   Always consider internationalization for user-facing strings.
-   Include appropriate error handling for async operations.
-   Consider performance implications, especially with MongoDB queries.
-   Use proper index definitions when querying MongoDB.
-   As much as possible use the components located in the `/app/components` folder.
-   Use the `useI18n` composable for translations.
-   As much as possible, implement SEO using useSeoMeta
-   Never omit code and leave behind `Existing Code` comments.
-   Always use `async/await` for asynchronous operations.
-   Components, utils, composables, helpers, models, interfaces and more are all automatically imported, so you can use them directly without needing to import them manually.
-   If you are unsure about a specific implementation, ask for clarification.
