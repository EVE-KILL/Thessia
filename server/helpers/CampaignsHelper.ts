import { createError } from 'h3';
import { type ICampaign } from '~/server/interfaces/ICampaign';
import { type ICampaignFilterEntities, type ICampaignOutput } from '~/server/interfaces/ICampaignOutput';
import { type IKillmail } from '~/server/interfaces/IKillmail';
import { type ITranslation } from '~/server/interfaces/ITranslation';
import { Alliances } from '~/server/models/Alliances';
import { Campaigns } from '~/server/models/Campaigns';
import { Characters } from '~/server/models/Characters';
import { Constellations } from '~/server/models/Constellations';
import { Corporations } from '~/server/models/Corporations';
import { Factions } from '~/server/models/Factions';
import { Killmails } from '~/server/models/Killmails';
import { Regions } from '~/server/models/Regions';
import { SolarSystems } from '~/server/models/SolarSystems';

/**
 * Interface for the statistics generated by the campaign helper.
 * @deprecated Use ICampaignOutput from '~/server/interfaces/ICampaignOutput' instead
 */
export interface ICampaignStatsOutput extends ICampaignOutput { }

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "attacker side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the attacker side, false otherwise.
 */
function isAttackerSide(
    entity: IKillmail['attackers'][0] | IKillmail['victim'],
    campaignQuery: ICampaign['query'],
): boolean {
    // Check direct attacker conditions
    if ('character_id' in entity && campaignQuery['attackers.character_id']) {
        const queryVal = campaignQuery['attackers.character_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if ('corporation_id' in entity && campaignQuery['attackers.corporation_id']) {
        const queryVal = campaignQuery['attackers.corporation_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ('alliance_id' in entity && campaignQuery['attackers.alliance_id']) {
        const queryVal = campaignQuery['attackers.alliance_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ('faction_id' in entity && campaignQuery['attackers.faction_id']) {
        const queryVal = campaignQuery['attackers.faction_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "victim side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the victim side, false otherwise.
 */
function isVictimSide(
    entity: IKillmail['attackers'][0] | IKillmail['victim'],
    campaignQuery: ICampaign['query'],
): boolean {
    // Check direct victim conditions
    if ('character_id' in entity && campaignQuery['victim.character_id']) {
        const queryVal = campaignQuery['victim.character_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if ('corporation_id' in entity && campaignQuery['victim.corporation_id']) {
        const queryVal = campaignQuery['victim.corporation_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ('alliance_id' in entity && campaignQuery['victim.alliance_id']) {
        const queryVal = campaignQuery['victim.alliance_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ('faction_id' in entity && campaignQuery['victim.faction_id']) {
        const queryVal = campaignQuery['victim.faction_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Transforms the campaign query into an expanded MongoDB query that respects
 * role separation - attackers remain attackers, victims remain victims.
 * @param campaignQuery - The original campaign query
 * @returns The expanded MongoDB query
 */
export function buildExpandedQuery(campaignQuery: ICampaign['query']): Record<string, any> {
    const expandedQuery: Record<string, any> = {};

    // Extract location and time filters
    const locationTimeFilters: Record<string, any> = {};

    // Process location and time filters
    ['region_id', 'system_id', 'constellation_id', 'kill_time'].forEach(key => {
        if (campaignQuery[key]) {
            locationTimeFilters[key] = campaignQuery[key];
        }
    });

    // Apply location and time filters directly to the main query
    Object.assign(expandedQuery, locationTimeFilters);

    // Separate attacker and victim entity specifications
    const attackerSpecs: Record<string, any> = {};
    const victimSpecs: Record<string, any> = {};

    // Collect attacker and victim specifications
    Object.entries(campaignQuery).forEach(([key, value]) => {
        if (key.startsWith('attackers.')) {
            attackerSpecs[key] = value;
        } else if (key.startsWith('victim.')) {
            victimSpecs[key] = value;
        }
    });

    const hasAttackerSpecs = Object.keys(attackerSpecs).length > 0;
    const hasVictimSpecs = Object.keys(victimSpecs).length > 0;

    // Handle different filter scenarios
    if (hasAttackerSpecs && hasVictimSpecs) {
        // Both attacker and victim specs are present - build a strict directional query
        const strictDirectionalQuery = buildStrictDirectionalQuery(attackerSpecs, victimSpecs);
        Object.assign(expandedQuery, strictDirectionalQuery);
    } else if (hasAttackerSpecs) {
        // Only attacker specs - build a query that only matches attackers
        const attackerQuery = buildAttackerOnlyQuery(attackerSpecs);
        Object.assign(expandedQuery, attackerQuery);
    } else if (hasVictimSpecs) {
        // Only victim specs - build a query that only matches victims
        const victimQuery = buildVictimOnlyQuery(victimSpecs);
        Object.assign(expandedQuery, victimQuery);
    }

    return expandedQuery;
}

/**
 * Build a strict directional query that only matches when attackers are attackers and victims are victims
 * @param attackerSpecs - Specifications for the attacker side
 * @param victimSpecs - Specifications for the victim side
 * @returns Query object that matches strict directional engagement
 */
function buildStrictDirectionalQuery(
    attackerSpecs: Record<string, any>,
    victimSpecs: Record<string, any>
): Record<string, any> {
    // Build query components for strict direction only
    const attackerSideAttacks = buildDirectionalMatchQuery(attackerSpecs, 'attackers.');
    const victimSideAsVictim = buildDirectionalMatchQuery(victimSpecs, 'victim.');

    // Only one direction: Attacker side attacks victim side
    return {
        $and: [attackerSideAttacks, victimSideAsVictim]
    };
}

/**
 * Build a query component that matches entities from specs in the given field prefix
 * @param specs - Entity specifications (attacker or victim)
 * @param fieldPrefix - Field prefix to match against ('attackers.' or 'victim.')
 * @returns Query object that matches entities in the specified fields
 */
function buildDirectionalMatchQuery(
    specs: Record<string, any>,
    fieldPrefix: 'attackers.' | 'victim.'
): Record<string, any> {
    const conditions: Record<string, any>[] = [];

    // Group specs by entity type for more efficient queries
    const entityTypeGroups: Record<string, any[]> = {};

    Object.entries(specs).forEach(([key, value]) => {
        // Extract entity type (e.g., 'character_id', 'corporation_id')
        const entityType = key.replace('attackers.', '').replace('victim.', '');

        if (!entityTypeGroups[entityType]) {
            entityTypeGroups[entityType] = [];
        }

        // Determine the field to match against based on prefix and entity type
        const matchField = `${fieldPrefix}${entityType}`;

        // Handle different value types ($in arrays or direct values)
        if (typeof value === 'object' && value !== null && '$in' in value) {
            conditions.push({ [matchField]: { $in: value.$in } });
        } else {
            conditions.push({ [matchField]: value });
        }
    });

    // For single condition, return it directly
    if (conditions.length === 1) {
        return conditions[0];
    }

    // For multiple conditions, use $or to match any of them
    return { $or: conditions };
}

/**
 * Build a query that only matches entities as attackers
 * @param specs - Entity specifications for attackers
 * @returns Query object that matches entities only in attacker role
 */
function buildAttackerOnlyQuery(specs: Record<string, any>): Record<string, any> {
    return buildDirectionalMatchQuery(specs, 'attackers.');
}

/**
 * Build a query that only matches entities as victims
 * @param specs - Entity specifications for victims
 * @returns Query object that matches entities only in victim role
 */
function buildVictimOnlyQuery(specs: Record<string, any>): Record<string, any> {
    return buildDirectionalMatchQuery(specs, 'victim.');
}

/**
 * Process campaign query and resolve entity IDs to names
 * @param campaignQuery - The campaign query object
 * @returns Object containing resolved entity data for the UI
 */
export async function processQueryForUI(campaignQuery: ICampaign['query']): Promise<ICampaignFilterEntities> {
    // Initialize the filter entities object
    const filterEntities: ICampaignFilterEntities = {
        regions: [],
        constellations: [],
        systems: [],
        attackerCharacters: [],
        attackerCorporations: [],
        attackerAlliances: [],
        attackerFactions: [],
        victimCharacters: [],
        victimCorporations: [],
        victimAlliances: [],
        victimFactions: []
    };

    // Process each filter type in parallel for performance
    await Promise.all([
        // Process locations
        processRegionIds(campaignQuery['region_id'], filterEntities),
        processConstellationIds(campaignQuery['constellation_id'], filterEntities),
        processSystemIds(campaignQuery['system_id'], filterEntities),

        // Process attacker entities
        processCharacterIds(campaignQuery['attackers.character_id'], filterEntities, 'attackerCharacters'),
        processCorporationIds(campaignQuery['attackers.corporation_id'], filterEntities, 'attackerCorporations'),
        processAllianceIds(campaignQuery['attackers.alliance_id'], filterEntities, 'attackerAlliances'),
        processFactionIds(campaignQuery['attackers.faction_id'], filterEntities, 'attackerFactions'),

        // Process victim entities
        processCharacterIds(campaignQuery['victim.character_id'], filterEntities, 'victimCharacters'),
        processCorporationIds(campaignQuery['victim.corporation_id'], filterEntities, 'victimCorporations'),
        processAllianceIds(campaignQuery['victim.alliance_id'], filterEntities, 'victimAlliances'),
        processFactionIds(campaignQuery['victim.faction_id'], filterEntities, 'victimFactions')
    ]);

    return filterEntities;
}

/**
 * Extract IDs from a query field value which may be a single ID or an $in array
 */
function extractIds(fieldValue: any): number[] {
    if (!fieldValue) return [];

    if (typeof fieldValue === 'object' && fieldValue !== null && '$in' in fieldValue) {
        return Array.isArray(fieldValue.$in) ? fieldValue.$in : [];
    }

    return typeof fieldValue === 'number' || typeof fieldValue === 'string'
        ? [Number(fieldValue)]
        : [];
}

/**
 * Process region IDs and add to filter entities
 */
async function processRegionIds(regionIdField: any, filterEntities: ICampaignFilterEntities): Promise<void> {
    const regionIds = extractIds(regionIdField);
    if (!regionIds.length) return;

    const regions = await Regions.find({ region_id: { $in: regionIds } }).lean();

    filterEntities.regions = regions.map(region => ({
        id: region.region_id,
        name: typeof region.name === 'object'
            ? region.name.en || Object.values(region.name)[0] || 'Unknown Region'
            : region.name || 'Unknown Region'
    }));
}

/**
 * Process constellation IDs and add to filter entities
 */
async function processConstellationIds(constellationIdField: any, filterEntities: ICampaignFilterEntities): Promise<void> {
    const constellationIds = extractIds(constellationIdField);
    if (!constellationIds.length) return;

    const constellations = await Constellations.find({ constellation_id: { $in: constellationIds } }).lean();

    filterEntities.constellations = constellations.map(constellation => ({
        id: constellation.constellation_id,
        name: constellation.constellation_name || 'Unknown Constellation'
    }));
}

/**
 * Process system IDs and add to filter entities
 */
async function processSystemIds(systemIdField: any, filterEntities: ICampaignFilterEntities): Promise<void> {
    const systemIds = extractIds(systemIdField);
    if (!systemIds.length) return;

    const systems = await SolarSystems.find({ system_id: { $in: systemIds } }).lean();

    filterEntities.systems = systems.map(system => ({
        id: system.system_id,
        name: system.system_name || 'Unknown System'
    }));
}

/**
 * Process character IDs and add to filter entities
 */
async function processCharacterIds(characterIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerCharacters' | 'victimCharacters'): Promise<void> {
    const characterIds = extractIds(characterIdField);
    if (!characterIds.length) return;

    const characters = await Characters.find({ character_id: { $in: characterIds } }).lean();

    filterEntities[key] = characters.map(character => ({
        id: character.character_id,
        name: character.name || 'Unknown Character'
    }));
}

/**
 * Process corporation IDs and add to filter entities
 */
async function processCorporationIds(corporationIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerCorporations' | 'victimCorporations'): Promise<void> {
    const corporationIds = extractIds(corporationIdField);
    if (!corporationIds.length) return;

    const corporations = await Corporations.find({ corporation_id: { $in: corporationIds } }).lean();

    filterEntities[key] = corporations.map(corporation => ({
        id: corporation.corporation_id,
        name: corporation.name || 'Unknown Corporation'
    }));
}

/**
 * Process alliance IDs and add to filter entities
 */
async function processAllianceIds(allianceIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerAlliances' | 'victimAlliances'): Promise<void> {
    const allianceIds = extractIds(allianceIdField);
    if (!allianceIds.length) return;

    const alliances = await Alliances.find({ alliance_id: { $in: allianceIds } }).lean();

    filterEntities[key] = alliances.map(alliance => ({
        id: alliance.alliance_id,
        name: alliance.name || 'Unknown Alliance'
    }));
}

/**
 * Process faction IDs and add to filter entities
 */
async function processFactionIds(factionIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerFactions' | 'victimFactions'): Promise<void> {
    const factionIds = extractIds(factionIdField);
    if (!factionIds.length) return;

    const factions = await Factions.find({ faction_id: { $in: factionIds } }).lean();

    filterEntities[key] = factions.map(faction => ({
        id: faction.faction_id,
        name: faction.name || 'Unknown Faction'
    }));
}

/**
 * Generates aggregated statistics for a campaign based on its ID or direct campaign data.
 * @param campaignIdOrData - Either the unique identifier of the campaign or complete campaign data object.
 * @returns An object containing the campaign statistics.
 */
export async function generateCampaignStats(
    campaignIdOrData: string | ICampaign
): Promise<ICampaignOutput> {
    // Fetch the campaign data or use provided data directly
    let campaign: ICampaign | null = null;

    if (typeof campaignIdOrData === 'string') {
        // Fetch the campaign data using ID
        campaign = await Campaigns.findOne({ campaign_id: campaignIdOrData }).lean();

        if (!campaign) {
            throw createError({
                statusCode: 404,
                statusMessage: 'Campaign not found',
            });
        }
    } else {
        // Use provided data directly
        campaign = campaignIdOrData;
    }

    // Process the campaign query to resolve entity names
    const filterEntities = await processQueryForUI(campaign.query);

    // Create an expanded query that handles attacker and victim entities properly
    const campaignQuery = campaign.query;
    const expandedQuery = buildExpandedQuery(campaignQuery);

    // Apply time constraints if not already included in the query
    if (!expandedQuery.kill_time) {
        expandedQuery.kill_time = {};
        if (campaign.startTime) {
            expandedQuery.kill_time.$gte = new Date(campaign.startTime);
        }
        if (campaign.endTime) {
            expandedQuery.kill_time.$lte = new Date(campaign.endTime);
        }
    }

    // Calculate runtime days in parallel with fetching killmails
    // Always calculate runtime from start time to current date, regardless of end time
    const runtimeDaysPromise = (async () => {
        const campaignStartTimeMs = new Date(campaign.startTime).getTime();
        const currentTimeMs = Date.now();
        return Math.floor((currentTimeMs - campaignStartTimeMs) / (1000 * 60 * 60 * 24));
    })();

    // Fetch all killmails using the expanded query
    const killmailsPromise = Killmails.find(expandedQuery).lean();

    // Wait for both operations to complete in parallel
    const [runtimeDays, relevantKillmails] = await Promise.all([runtimeDaysPromise, killmailsPromise]);

    const stats: ICampaignOutput = {
        // Include campaign metadata
        name: campaign.name,
        description: campaign.description,
        startTime: new Date(campaign.startTime),
        endTime: campaign.endTime ? new Date(campaign.endTime) : undefined,
        creator_id: campaign.creator_id,
        campaignQuery: campaignQuery,
        filterEntities: filterEntities,

        // Initialize statistics
        totalKills: 0,
        totalLosses: 0,
        iskDamageDoneAttacker: 0,
        iskDamageDoneVictim: 0,
        iskDamageReceivedAttacker: 0,
        iskDamageReceivedVictim: 0,
        runtimeDays,
        efficiency: 0,
        attackerVsVictim: false,
        shipGroupStats: [],
        topKillersByCharacter: [],
        topDamageDealersByCharacter: [],
        killmailIds: [],
    };

    // Determine if this is an attacker vs victim campaign
    stats.attackerVsVictim = Object.keys(campaignQuery).some(key =>
        key.startsWith('attackers.') || key.startsWith('victim.')
    );

    // Initialize aggregation maps
    const shipGroupMap = new Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>();
    const characterKillsMap = new Map<number, { character_id: number; character_name: string; kills: number }>();
    const characterLossesMap = new Map<number, { character_id: number; character_name: string; losses: number }>();
    const characterDamageMap = new Map<number, { character_id: number; character_name: string; damageDone: number }>();

    // Track unique kills by killmail_id to prevent double counting
    const trackedKillmails = new Set<number>();
    const trackedForStats = new Set<number>();

    // Collect all killmail IDs without limiting
    const killmailIds: number[] = [];

    // Optimization: Process killmails in batches to avoid blocking the event loop
    const BATCH_SIZE = 500;
    const killmailBatches = [];

    for (let i = 0; i < relevantKillmails.length; i += BATCH_SIZE) {
        killmailBatches.push(relevantKillmails.slice(i, i + BATCH_SIZE));
    }

    // Process each batch
    let killmailIdIndex = 0;

    // Using Promise.all to process batches in parallel, with internal sequential processing
    await Promise.all(killmailBatches.map(async (batch, batchIndex) => {
        return processKillmailBatch(
            batch,
            stats,
            campaignQuery,
            shipGroupMap,
            characterKillsMap,
            characterLossesMap,
            characterDamageMap,
            trackedKillmails,
            trackedForStats,
            killmailIds,
            killmailIdIndex + (batchIndex * BATCH_SIZE)
        );
    }));

    // Perform final calculations in parallel
    const [shipGroupStats, topKillers, topVictims, topDamageDealers] = await Promise.all([
        (async () => Array.from(shipGroupMap.values()))(),
        (async () => Array.from(characterKillsMap.values())
            .sort((a, b) => b.kills - a.kills)
            .slice(0, 10))(),
        (async () => Array.from(characterLossesMap.values())
            .sort((a, b) => b.losses - a.losses)
            .slice(0, 10))(),
        (async () => Array.from(characterDamageMap.values())
            .sort((a, b) => b.damageDone - a.damageDone)
            .slice(0, 10))()
    ]);

    // Determine what to show in topKillersByCharacter based on campaign type
    const hasAttackerDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('attackers.'));
    const hasVictimDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('victim.'));

    let topCharacters = topKillers;
    if (hasVictimDefinitions && !hasAttackerDefinitions) {
        // Victim-only campaign: show top victims as "losers" but convert to killers format
        topCharacters = topVictims.map(victim => ({
            character_id: victim.character_id,
            character_name: victim.character_name,
            kills: victim.losses  // Show losses as "participation"
        }));
    } else if (topKillers.length === 0 && topVictims.length > 0) {
        // Fallback: if no killers data but have victims, show victims
        topCharacters = topVictims.map(victim => ({
            character_id: victim.character_id,
            character_name: victim.character_name,
            kills: victim.losses
        }));
    }

    // Calculate efficiency
    if (stats.attackerVsVictim && stats.iskDamageReceivedAttacker > 0) {
        stats.efficiency = stats.iskDamageDoneAttacker / stats.iskDamageReceivedAttacker;
    } else {
        stats.efficiency = 0;
    }

    // Include ALL killmail IDs without filtering
    stats.killmailIds = killmailIds.filter(id => id !== undefined && id !== null);
    stats.shipGroupStats = shipGroupStats;
    stats.topKillersByCharacter = topCharacters;
    stats.topDamageDealersByCharacter = topDamageDealers;

    return stats;
}

/**
 * Process a batch of killmails to update statistics
 * @param batch - Batch of killmails to process
 * @param stats - Statistics object to update
 * @param campaignQuery - Original campaign query
 * @param shipGroupMap - Map of ship group stats
 * @param characterKillsMap - Map of character kill stats
 * @param characterDamageMap - Map of character damage stats
 * @param trackedKillmails - Set of tracked killmail IDs
 * @param trackedForStats - Set of tracked killmail IDs for stats consistency
 * @param killmailIds - Array to store killmail IDs
 * @param killmailIdIndex - Starting index for killmail IDs
 */
async function processKillmailBatch(
    batch: IKillmail[],
    stats: ICampaignOutput,
    campaignQuery: ICampaign['query'],
    shipGroupMap: Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    characterLossesMap: Map<number, { character_id: number; character_name: string; losses: number }>,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    trackedKillmails: Set<number>,
    trackedForStats: Set<number>,
    killmailIds: number[],
    killmailIdIndex: number
): Promise<void> {
    let localIndex = killmailIdIndex;

    for (const km of batch) {
        if (!km.victim || !km.attackers || km.attackers.length === 0) continue;

        // Store the killmail ID directly in array at the calculated position
        if (km.killmail_id) {
            killmailIds[localIndex++] = km.killmail_id;
        }

        // Process attacker and victim side determination in parallel
        const [victimOnAttackerSide, victimOnVictimSide, attackersOnAttackerSide, attackersOnVictimSide] = await Promise.all([
            isAttackerSide(km.victim, campaignQuery),
            isVictimSide(km.victim, campaignQuery),
            (async () => km.attackers.some((att: any) => isAttackerSide(att, campaignQuery)))(),
            (async () => km.attackers.some((att: any) => isVictimSide(att, campaignQuery)))()
        ]);

        if (stats.attackerVsVictim) {
            // Check if campaign defines any attackers
            const hasAttackerDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('attackers.'));
            const hasVictimDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('victim.'));

            // Attribution logic for kills, losses and ISK damage
            if (hasAttackerDefinitions && attackersOnAttackerSide && !victimOnAttackerSide) {
                // Campaign-defined attackers killed a non-campaign entity
                stats.totalKills++;
                stats.iskDamageDoneAttacker += km.total_value || 0;

                // Add to tracked killmails for stats consistency
                if (!trackedForStats.has(km.killmail_id)) {
                    trackedForStats.add(km.killmail_id);
                }
            }

            if (hasAttackerDefinitions && victimOnAttackerSide) {
                // A campaign-defined attacker entity was killed
                stats.totalLosses++;
                stats.iskDamageReceivedAttacker += km.total_value || 0;

                // Add to tracked killmails for stats consistency
                if (!trackedForStats.has(km.killmail_id)) {
                    trackedForStats.add(km.killmail_id);
                }
            }

            if (hasVictimDefinitions && victimOnVictimSide) {
                // A campaign-defined victim entity was killed (loss)
                stats.totalLosses++;
                stats.iskDamageReceivedVictim += km.total_value || 0;

                // Add to tracked killmails for stats consistency
                if (!trackedForStats.has(km.killmail_id)) {
                    trackedForStats.add(km.killmail_id);
                }
            }

            // For victim-only campaigns, we don't count kills when victims attack others
            // The campaign is tracking losses of the victim entities, not their kills
            if (hasVictimDefinitions && !hasAttackerDefinitions && attackersOnVictimSide && !victimOnVictimSide) {
                // This is a victim-only campaign, but victim entities killed someone else
                // We don't count this as a kill because we're only tracking their losses
                // Just track the ISK damage for completeness
                stats.iskDamageDoneVictim += km.total_value || 0;
            } else if (hasVictimDefinitions && hasAttackerDefinitions && attackersOnVictimSide && !victimOnVictimSide) {
                // This is an attacker vs victim campaign, and victim entities killed a non-campaign entity
                stats.totalKills++;
                stats.iskDamageDoneVictim += km.total_value || 0;

                // Add to tracked killmails for stats consistency
                if (!trackedForStats.has(km.killmail_id)) {
                    trackedForStats.add(km.killmail_id);
                }
            }
        } else { // General Tracking - count all kills
            stats.totalKills++;
            stats.iskDamageDoneAttacker += km.total_value || 0;
        }

        // Process ship group stats and character stats
        await Promise.all([
            processShipGroupStat(km, stats, shipGroupMap, victimOnAttackerSide, attackersOnAttackerSide, victimOnVictimSide, attackersOnVictimSide),
            processCharacterStats(km, stats, characterKillsMap, characterLossesMap, characterDamageMap, campaignQuery, trackedKillmails, victimOnAttackerSide, attackersOnAttackerSide, victimOnVictimSide, attackersOnVictimSide)
        ]);
    }
}

/**
 * Process ship group statistics for a killmail
 */
async function processShipGroupStat(
    km: IKillmail,
    stats: ICampaignOutput,
    shipGroupMap: Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    const victimShipGroupName = km.victim.ship_group_name || { en: 'Unknown Ship Group' };
    const victimShipGroupNameKey = typeof victimShipGroupName === 'object'
        ? (victimShipGroupName.en || Object.values(victimShipGroupName)[0] || 'Unknown Ship Group')
        : victimShipGroupName;

    let shipStat = shipGroupMap.get(victimShipGroupNameKey);
    if (!shipStat) {
        shipStat = {
            ship_group_id: km.victim.ship_group_id || 0,
            ship_group_name: victimShipGroupName,
            killed: 0,
            lost: 0,
        };
        shipGroupMap.set(victimShipGroupNameKey, shipStat);
    }

    if (stats.attackerVsVictim) {
        // Check if campaign defines any attackers or victims
        const hasAttackerDefinitions = Object.keys(stats.campaignQuery).some(key => key.startsWith('attackers.'));
        const hasVictimDefinitions = Object.keys(stats.campaignQuery).some(key => key.startsWith('victim.'));

        if (hasAttackerDefinitions && victimOnAttackerSide) {
            // Campaign-defined attacker lost a ship
            shipStat.lost++;
        } else if (hasAttackerDefinitions && attackersOnAttackerSide) {
            // Campaign-defined attackers killed a ship
            shipStat.killed++;
        }

        if (hasVictimDefinitions && victimOnVictimSide) {
            // Campaign-defined victim lost a ship
            shipStat.lost++;
        } else if (hasVictimDefinitions && !hasAttackerDefinitions && attackersOnVictimSide) {
            // This is a victim-only campaign and victim entities killed someone else
            // For victim-only campaigns, we don't count this as a "kill" because we're tracking their losses
            // We only track the ship that was killed (by the victim entities), not as a kill for the campaign
            // Do nothing - don't increment killed count for victim-only campaigns
        } else if (hasVictimDefinitions && hasAttackerDefinitions && attackersOnVictimSide) {
            // This is an attacker vs victim campaign and victim entities killed someone
            shipStat.killed++;
        }
    } else { // General Tracking
        shipStat.killed++; // All losses are "kills" from campaign perspective
    }
}

/**
 * Process character statistics for a killmail
 */
async function processCharacterStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    characterLossesMap: Map<number, { character_id: number; character_name: string; losses: number }>,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    campaignQuery: ICampaign['query'],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    // Process killer attribution, victim attribution, and damage in parallel
    await Promise.all([
        processKillerAttribution(km, stats, characterKillsMap, campaignQuery, trackedKillmails, victimOnAttackerSide, attackersOnAttackerSide, victimOnVictimSide, attackersOnVictimSide),
        processVictimAttribution(km, stats, characterLossesMap, campaignQuery, trackedKillmails, victimOnAttackerSide, attackersOnAttackerSide, victimOnVictimSide, attackersOnVictimSide),
        processDamageStats(km, stats, characterDamageMap, campaignQuery)
    ]);
}

/**
 * Process killer attribution for a killmail
 */
async function processKillerAttribution(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    campaignQuery: ICampaign['query'],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    // Check if campaign defines any attackers or victims
    const hasAttackerDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('attackers.'));
    const hasVictimDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('victim.'));

    if (stats.attackerVsVictim) {
        // For mixed campaigns (both attackers and victims defined), we track kills differently
        if (hasAttackerDefinitions && hasVictimDefinitions) {
            // Mixed campaign: track kills by campaign-defined entities (both sides)
            let finalBlowAttacker = km.attackers.find((a: any) => a.is_final_blow && (isAttackerSide(a, campaignQuery) || isVictimSide(a, campaignQuery)));

            // If no final blow from campaign entities, find top damage dealer from campaign entities
            if (!finalBlowAttacker) {
                finalBlowAttacker = km.attackers
                    .filter((a: any) => isAttackerSide(a, campaignQuery) || isVictimSide(a, campaignQuery))
                    .sort((a: any, b: any) => (b.damage_done || 0) - (a.damage_done || 0))[0];
            }

            // If we have a valid campaign entity to attribute the kill to
            if (finalBlowAttacker && finalBlowAttacker.character_id) {
                let killerStat = characterKillsMap.get(finalBlowAttacker.character_id);
                if (!killerStat) {
                    killerStat = {
                        character_id: finalBlowAttacker.character_id,
                        character_name: finalBlowAttacker.character_name || 'Unknown Character',
                        kills: 0,
                    };
                    characterKillsMap.set(finalBlowAttacker.character_id, killerStat);
                }

                // Only increment if we haven't counted this killmail for this character
                if (!trackedKillmails.has(km.killmail_id)) {
                    killerStat.kills++;
                    trackedKillmails.add(km.killmail_id);
                }
            }
        } else if (hasAttackerDefinitions && attackersOnAttackerSide && !victimOnAttackerSide) {
            // Campaign-defined attackers killed a non-campaign entity
            // First try to attribute to final blow if they're on attacker side
            let finalBlowAttacker = km.attackers.find((a: any) => a.is_final_blow && isAttackerSide(a, campaignQuery));

            // If no final blow attacker on attacker side, find the top damage dealer on attacker side
            if (!finalBlowAttacker) {
                finalBlowAttacker = km.attackers
                    .filter((a: any) => isAttackerSide(a, campaignQuery))
                    .sort((a: any, b: any) => (b.damage_done || 0) - (a.damage_done || 0))[0];
            }

            // If we have a valid attacker to attribute the kill to
            if (finalBlowAttacker && finalBlowAttacker.character_id) {
                let killerStat = characterKillsMap.get(finalBlowAttacker.character_id);
                if (!killerStat) {
                    killerStat = {
                        character_id: finalBlowAttacker.character_id,
                        character_name: finalBlowAttacker.character_name || 'Unknown Character',
                        kills: 0,
                    };
                    characterKillsMap.set(finalBlowAttacker.character_id, killerStat);
                }

                // Only increment if we haven't counted this killmail for this character
                if (!trackedKillmails.has(km.killmail_id)) {
                    killerStat.kills++;
                    trackedKillmails.add(km.killmail_id);
                }
            }
        } else if (hasVictimDefinitions && !hasAttackerDefinitions) {
            // Victim-only campaign: don't track kills since we only care about losses
        }
    } else {
        // General tracking - attribute kill to the final blow attacker
        const finalBlowAttacker = km.attackers.find((a: any) => a.is_final_blow);

        if (finalBlowAttacker && finalBlowAttacker.character_id) {
            let killerStat = characterKillsMap.get(finalBlowAttacker.character_id);
            if (!killerStat) {
                killerStat = {
                    character_id: finalBlowAttacker.character_id,
                    character_name: finalBlowAttacker.character_name || 'Unknown Character',
                    kills: 0,
                };
                characterKillsMap.set(finalBlowAttacker.character_id, killerStat);
            }

            // Only increment if we haven't counted this killmail for this character
            if (!trackedKillmails.has(km.killmail_id)) {
                killerStat.kills++;
                trackedKillmails.add(km.killmail_id);
            }
        }
    }
}

/**
 * Process victim attribution for a killmail
 */
async function processVictimAttribution(
    km: IKillmail,
    stats: ICampaignOutput,
    characterLossesMap: Map<number, { character_id: number; character_name: string; losses: number }>,
    campaignQuery: ICampaign['query'],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    // Check if campaign defines any attackers or victims
    const hasAttackerDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('attackers.'));
    const hasVictimDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('victim.'));

    // Track victim character for campaign-relevant losses
    if (km.victim && km.victim.character_id) {
        let shouldTrackVictim = false;

        if (stats.attackerVsVictim) {
            // For attacker vs victim campaigns, track based on campaign definitions
            if (hasVictimDefinitions && victimOnVictimSide) {
                // Campaign-defined victim was killed
                shouldTrackVictim = true;
            } else if (hasAttackerDefinitions && victimOnAttackerSide) {
                // Campaign-defined attacker was killed (attacker became victim)
                shouldTrackVictim = true;
            }
        } else {
            // For general campaigns (location/time based), track all victims
            shouldTrackVictim = true;
        }

        if (shouldTrackVictim) {
            let victimStat = characterLossesMap.get(km.victim.character_id);
            if (!victimStat) {
                victimStat = {
                    character_id: km.victim.character_id,
                    character_name: km.victim.character_name || 'Unknown Character',
                    losses: 0,
                };
                characterLossesMap.set(km.victim.character_id, victimStat);
            }
            victimStat.losses++;
        }
    }
}

/**
 * Process damage statistics for a killmail
 */
async function processDamageStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    campaignQuery: ICampaign['query']
): Promise<void> {
    // Process all attackers in parallel for damage stats
    await Promise.all(km.attackers.map(async (attacker: any) => {
        if (!attacker.character_id || attacker.damage_done === 0) return;

        if (stats.attackerVsVictim) {
            // Check if campaign defines any attackers or victims
            const hasAttackerDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('attackers.'));
            const hasVictimDefinitions = Object.keys(campaignQuery).some(key => key.startsWith('victim.'));

            // Count damage for attackers on the attacker side
            if (hasAttackerDefinitions && await isAttackerSide(attacker, campaignQuery)) {
                let damageDealerStat = characterDamageMap.get(attacker.character_id);
                if (!damageDealerStat) {
                    damageDealerStat = {
                        character_id: attacker.character_id,
                        character_name: attacker.character_name || 'Unknown Character',
                        damageDone: 0,
                    };
                    characterDamageMap.set(attacker.character_id, damageDealerStat);
                }
                damageDealerStat.damageDone += attacker.damage_done || 0;
            }

            // Count damage for victim entities ONLY if this is an attacker vs victim campaign
            // For victim-only campaigns, we don't track damage dealt by victims as "damage done"
            if (hasVictimDefinitions && hasAttackerDefinitions && await isVictimSide(attacker, campaignQuery)) {
                let damageDealerStat = characterDamageMap.get(attacker.character_id);
                if (!damageDealerStat) {
                    damageDealerStat = {
                        character_id: attacker.character_id,
                        character_name: attacker.character_name || 'Unknown Character',
                        damageDone: 0,
                    };
                    characterDamageMap.set(attacker.character_id, damageDealerStat);
                }
                damageDealerStat.damageDone += attacker.damage_done || 0;
            }
        } else { // General Tracking
            let damageDealerStat = characterDamageMap.get(attacker.character_id);
            if (!damageDealerStat) {
                damageDealerStat = {
                    character_id: attacker.character_id,
                    character_name: attacker.character_name || 'Unknown Character',
                    damageDone: 0,
                };
                characterDamageMap.set(attacker.character_id, damageDealerStat);
            }
            damageDealerStat.damageDone += attacker.damage_done || 0;
        }
    }));
}
