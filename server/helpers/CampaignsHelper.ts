import { createError } from 'h3';
import { type ICampaign } from '~/server/interfaces/ICampaign';
import { type ICampaignFilterEntities, type ICampaignOutput } from '~/server/interfaces/ICampaignOutput';
import { type IKillmail } from '~/server/interfaces/IKillmail';
import { type ITranslation } from '~/server/interfaces/ITranslation';
import { Alliances } from '~/server/models/Alliances';
import { Campaigns } from '~/server/models/Campaigns';
import { Characters } from '~/server/models/Characters';
import { Constellations } from '~/server/models/Constellations';
import { Corporations } from '~/server/models/Corporations';
import { Factions } from '~/server/models/Factions';
import { Killmails } from '~/server/models/Killmails';
import { Regions } from '~/server/models/Regions';
import { SolarSystems } from '~/server/models/SolarSystems';

/**
 * Interface for the statistics generated by the campaign helper.
 * @deprecated Use ICampaignOutput from '~/server/interfaces/ICampaignOutput' instead
 */
export interface ICampaignStatsOutput extends ICampaignOutput { }

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "attacker side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the attacker side, false otherwise.
 */
function isAttackerSide(
    entity: IKillmail['attackers'][0] | IKillmail['victim'],
    campaignQuery: ICampaign['query'],
): boolean {
    // Check direct attacker conditions
    if ('character_id' in entity && campaignQuery['attackers.character_id']) {
        const queryVal = campaignQuery['attackers.character_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if ('corporation_id' in entity && campaignQuery['attackers.corporation_id']) {
        const queryVal = campaignQuery['attackers.corporation_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ('alliance_id' in entity && campaignQuery['attackers.alliance_id']) {
        const queryVal = campaignQuery['attackers.alliance_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ('faction_id' in entity && campaignQuery['attackers.faction_id']) {
        const queryVal = campaignQuery['attackers.faction_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "victim side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the victim side, false otherwise.
 */
function isVictimSide(
    entity: IKillmail['attackers'][0] | IKillmail['victim'],
    campaignQuery: ICampaign['query'],
): boolean {
    // Check direct victim conditions
    if ('character_id' in entity && campaignQuery['victim.character_id']) {
        const queryVal = campaignQuery['victim.character_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if ('corporation_id' in entity && campaignQuery['victim.corporation_id']) {
        const queryVal = campaignQuery['victim.corporation_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ('alliance_id' in entity && campaignQuery['victim.alliance_id']) {
        const queryVal = campaignQuery['victim.alliance_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ('faction_id' in entity && campaignQuery['victim.faction_id']) {
        const queryVal = campaignQuery['victim.faction_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Transforms the campaign query into an expanded MongoDB query that properly handles
 * attackers and victims being on either side of the engagement.
 * @param campaignQuery - The original campaign query
 * @returns The expanded MongoDB query
 */
export function buildExpandedQuery(campaignQuery: ICampaign['query']): Record<string, any> {
    const expandedQuery: Record<string, any> = {};
    const conditions: any[] = [];

    // Extract entity IDs for potential cross-referencing
    const attackerEntities: Record<string, any> = {};
    const victimEntities: Record<string, any> = {};

    // Process each key in the original query
    Object.entries(campaignQuery).forEach(([key, value]) => {
        // Handle time range and region directly - these don't need expansion
        if (key === 'kill_time' || key === 'region_id' || key === 'system_id' || key === 'constellation_id') {
            expandedQuery[key] = value;
            return;
        }

        // Process attacker entities
        if (key.startsWith('attackers.')) {
            const entityType = key.replace('attackers.', '');
            attackerEntities[entityType] = value;
        }

        // Process victim entities
        else if (key.startsWith('victim.')) {
            const entityType = key.replace('victim.', '');
            victimEntities[entityType] = value;
        }
    });

    // Build OR conditions for attackers
    Object.entries(attackerEntities).forEach(([entityType, entityValue]) => {
        // Create conditions for both attacker and victim roles
        if (typeof entityValue === 'object' && entityValue !== null && '$in' in entityValue) {
            // Handle $in operator
            conditions.push({ [`attackers.${entityType}`]: entityValue });
            // No need to add victim condition for $in as we'll handle this separately
        } else {
            // Direct equality
            conditions.push({ [`attackers.${entityType}`]: entityValue });
        }
    });

    // Build OR conditions for victims
    Object.entries(victimEntities).forEach(([entityType, entityValue]) => {
        // Create conditions for both attacker and victim roles
        if (typeof entityValue === 'object' && entityValue !== null && '$in' in entityValue) {
            // Handle $in operator
            conditions.push({ [`victim.${entityType}`]: entityValue });
        } else {
            // Direct equality
            conditions.push({ [`victim.${entityType}`]: entityValue });
        }
    });

    // Add the OR conditions to the query if we have any
    if (conditions.length > 0) {
        expandedQuery.$or = conditions;
    }

    return expandedQuery;
}

/**
 * Process campaign query and resolve entity IDs to names
 * @param campaignQuery - The campaign query object
 * @returns Object containing resolved entity data for the UI
 */
async function processQueryForUI(campaignQuery: ICampaign['query']): Promise<ICampaignFilterEntities> {
    // Initialize the filter entities object
    const filterEntities: ICampaignFilterEntities = {
        regions: [],
        constellations: [],
        systems: [],
        attackerCharacters: [],
        attackerCorporations: [],
        attackerAlliances: [],
        attackerFactions: [],
        victimCharacters: [],
        victimCorporations: [],
        victimAlliances: [],
        victimFactions: []
    };

    // Process each filter type in parallel for performance
    await Promise.all([
        // Process locations
        processRegionIds(campaignQuery['region_id'], filterEntities),
        processConstellationIds(campaignQuery['constellation_id'], filterEntities),
        processSystemIds(campaignQuery['system_id'], filterEntities),

        // Process attacker entities
        processCharacterIds(campaignQuery['attackers.character_id'], filterEntities, 'attackerCharacters'),
        processCorporationIds(campaignQuery['attackers.corporation_id'], filterEntities, 'attackerCorporations'),
        processAllianceIds(campaignQuery['attackers.alliance_id'], filterEntities, 'attackerAlliances'),
        processFactionIds(campaignQuery['attackers.faction_id'], filterEntities, 'attackerFactions'),

        // Process victim entities
        processCharacterIds(campaignQuery['victim.character_id'], filterEntities, 'victimCharacters'),
        processCorporationIds(campaignQuery['victim.corporation_id'], filterEntities, 'victimCorporations'),
        processAllianceIds(campaignQuery['victim.alliance_id'], filterEntities, 'victimAlliances'),
        processFactionIds(campaignQuery['victim.faction_id'], filterEntities, 'victimFactions')
    ]);

    return filterEntities;
}

/**
 * Extract IDs from a query field value which may be a single ID or an $in array
 */
function extractIds(fieldValue: any): number[] {
    if (!fieldValue) return [];

    if (typeof fieldValue === 'object' && fieldValue !== null && '$in' in fieldValue) {
        return Array.isArray(fieldValue.$in) ? fieldValue.$in : [];
    }

    return typeof fieldValue === 'number' || typeof fieldValue === 'string'
        ? [Number(fieldValue)]
        : [];
}

/**
 * Process region IDs and add to filter entities
 */
async function processRegionIds(regionIdField: any, filterEntities: ICampaignFilterEntities): Promise<void> {
    const regionIds = extractIds(regionIdField);
    if (!regionIds.length) return;

    const regions = await Regions.find({ region_id: { $in: regionIds } }).lean();

    filterEntities.regions = regions.map(region => ({
        id: region.region_id,
        name: typeof region.name === 'object'
            ? region.name.en || Object.values(region.name)[0] || 'Unknown Region'
            : region.name || 'Unknown Region'
    }));
}

/**
 * Process constellation IDs and add to filter entities
 */
async function processConstellationIds(constellationIdField: any, filterEntities: ICampaignFilterEntities): Promise<void> {
    const constellationIds = extractIds(constellationIdField);
    if (!constellationIds.length) return;

    const constellations = await Constellations.find({ constellation_id: { $in: constellationIds } }).lean();

    filterEntities.constellations = constellations.map(constellation => ({
        id: constellation.constellation_id,
        name: constellation.constellation_name || 'Unknown Constellation'
    }));
}

/**
 * Process system IDs and add to filter entities
 */
async function processSystemIds(systemIdField: any, filterEntities: ICampaignFilterEntities): Promise<void> {
    const systemIds = extractIds(systemIdField);
    if (!systemIds.length) return;

    const systems = await SolarSystems.find({ system_id: { $in: systemIds } }).lean();

    filterEntities.systems = systems.map(system => ({
        id: system.system_id,
        name: system.system_name || 'Unknown System'
    }));
}

/**
 * Process character IDs and add to filter entities
 */
async function processCharacterIds(characterIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerCharacters' | 'victimCharacters'): Promise<void> {
    const characterIds = extractIds(characterIdField);
    if (!characterIds.length) return;

    const characters = await Characters.find({ character_id: { $in: characterIds } }).lean();

    filterEntities[key] = characters.map(character => ({
        id: character.character_id,
        name: character.name || 'Unknown Character'
    }));
}

/**
 * Process corporation IDs and add to filter entities
 */
async function processCorporationIds(corporationIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerCorporations' | 'victimCorporations'): Promise<void> {
    const corporationIds = extractIds(corporationIdField);
    if (!corporationIds.length) return;

    const corporations = await Corporations.find({ corporation_id: { $in: corporationIds } }).lean();

    filterEntities[key] = corporations.map(corporation => ({
        id: corporation.corporation_id,
        name: corporation.name || 'Unknown Corporation'
    }));
}

/**
 * Process alliance IDs and add to filter entities
 */
async function processAllianceIds(allianceIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerAlliances' | 'victimAlliances'): Promise<void> {
    const allianceIds = extractIds(allianceIdField);
    if (!allianceIds.length) return;

    const alliances = await Alliances.find({ alliance_id: { $in: allianceIds } }).lean();

    filterEntities[key] = alliances.map(alliance => ({
        id: alliance.alliance_id,
        name: alliance.name || 'Unknown Alliance'
    }));
}

/**
 * Process faction IDs and add to filter entities
 */
async function processFactionIds(factionIdField: any, filterEntities: ICampaignFilterEntities, key: 'attackerFactions' | 'victimFactions'): Promise<void> {
    const factionIds = extractIds(factionIdField);
    if (!factionIds.length) return;

    const factions = await Factions.find({ faction_id: { $in: factionIds } }).lean();

    filterEntities[key] = factions.map(faction => ({
        id: faction.faction_id,
        name: faction.name || 'Unknown Faction'
    }));
}

/**
 * Generates aggregated statistics for a campaign based on its ID or direct campaign data.
 * @param campaignIdOrData - Either the unique identifier of the campaign or complete campaign data object.
 * @returns An object containing the campaign statistics.
 */
export async function generateCampaignStats(
    campaignIdOrData: string | ICampaign
): Promise<ICampaignOutput> {
    // Fetch the campaign data or use provided data directly
    let campaign: ICampaign | null = null;

    if (typeof campaignIdOrData === 'string') {
        // Fetch the campaign data using ID
        campaign = await Campaigns.findOne({ campaign_id: campaignIdOrData }).lean();

        if (!campaign) {
            throw createError({
                statusCode: 404,
                statusMessage: 'Campaign not found',
            });
        }
    } else {
        // Use provided data directly
        campaign = campaignIdOrData;
    }

    // Process the campaign query to resolve entity names
    const filterEntities = await processQueryForUI(campaign.query);

    // Create an expanded query that handles attacker and victim entities properly
    const campaignQuery = campaign.query;
    const expandedQuery = buildExpandedQuery(campaignQuery);

    // Apply time constraints if not already included in the query
    if (!expandedQuery.kill_time) {
        expandedQuery.kill_time = {};
        if (campaign.startTime) {
            expandedQuery.kill_time.$gte = new Date(campaign.startTime);
        }
        if (campaign.endTime) {
            expandedQuery.kill_time.$lte = new Date(campaign.endTime);
        }
    }

    // Calculate runtime days in parallel with fetching killmails
    // Always calculate runtime from start time to current date, regardless of end time
    const runtimeDaysPromise = (async () => {
        const campaignStartTimeMs = new Date(campaign.startTime).getTime();
        const currentTimeMs = Date.now();
        return Math.floor((currentTimeMs - campaignStartTimeMs) / (1000 * 60 * 60 * 24));
    })();

    // Fetch all killmails using the expanded query
    const killmailsPromise = Killmails.find(expandedQuery).lean();

    // Wait for both operations to complete in parallel
    const [runtimeDays, relevantKillmails] = await Promise.all([runtimeDaysPromise, killmailsPromise]);

    const stats: ICampaignOutput = {
        // Include campaign metadata
        name: campaign.name,
        description: campaign.description,
        startTime: new Date(campaign.startTime),
        endTime: campaign.endTime ? new Date(campaign.endTime) : undefined,
        creator_id: campaign.creator_id,
        campaignQuery: campaignQuery,
        filterEntities: filterEntities,

        // Initialize statistics
        totalKills: 0,
        totalLosses: 0,
        iskDamageDoneAttacker: 0,
        iskDamageDoneVictim: 0,
        iskDamageReceivedAttacker: 0,
        iskDamageReceivedVictim: 0,
        runtimeDays,
        efficiency: 0,
        attackerVsVictim: false,
        shipGroupStats: [],
        topKillersByCharacter: [],
        topDamageDealersByCharacter: [],
        killmailIds: [],
    };

    // Determine if this is an attacker vs victim campaign
    stats.attackerVsVictim = Object.keys(campaignQuery).some(key =>
        key.startsWith('attackers.') || key.startsWith('victim.')
    );

    // Initialize aggregation maps
    const shipGroupMap = new Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>();
    const characterKillsMap = new Map<number, { character_id: number; character_name: string; kills: number }>();
    const characterDamageMap = new Map<number, { character_id: number; character_name: string; damageDone: number }>();

    // Track unique kills by killmail_id to prevent double counting
    const trackedKillmails = new Set<number>();
    const trackedForStats = new Set<number>();

    // Collect all killmail IDs without limiting
    const killmailIds: number[] = [];

    // Optimization: Process killmails in batches to avoid blocking the event loop
    const BATCH_SIZE = 500;
    const killmailBatches = [];

    for (let i = 0; i < relevantKillmails.length; i += BATCH_SIZE) {
        killmailBatches.push(relevantKillmails.slice(i, i + BATCH_SIZE));
    }

    console.log(`Processing ${relevantKillmails.length} killmails in ${killmailBatches.length} batches`);

    // Process each batch
    let killmailIdIndex = 0;

    // Using Promise.all to process batches in parallel, with internal sequential processing
    await Promise.all(killmailBatches.map(async (batch, batchIndex) => {
        return processKillmailBatch(
            batch,
            stats,
            campaignQuery,
            shipGroupMap,
            characterKillsMap,
            characterDamageMap,
            trackedKillmails,
            trackedForStats,
            killmailIds,
            killmailIdIndex + (batchIndex * BATCH_SIZE)
        );
    }));

    // Perform final calculations in parallel
    const [shipGroupStats, topKillers, topDamageDealers] = await Promise.all([
        (async () => Array.from(shipGroupMap.values()))(),
        (async () => Array.from(characterKillsMap.values())
            .sort((a, b) => b.kills - a.kills)
            .slice(0, 10))(),
        (async () => Array.from(characterDamageMap.values())
            .sort((a, b) => b.damageDone - a.damageDone)
            .slice(0, 10))()
    ]);

    // Calculate efficiency
    if (stats.attackerVsVictim && stats.iskDamageReceivedAttacker > 0) {
        stats.efficiency = stats.iskDamageDoneAttacker / stats.iskDamageReceivedAttacker;
    } else {
        stats.efficiency = 0;
    }

    // Include ALL killmail IDs without filtering
    stats.killmailIds = killmailIds.filter(id => id !== undefined && id !== null);
    stats.shipGroupStats = shipGroupStats;
    stats.topKillersByCharacter = topKillers;
    stats.topDamageDealersByCharacter = topDamageDealers;

    return stats;
}

/**
 * Process a batch of killmails to update statistics
 * @param batch - Batch of killmails to process
 * @param stats - Statistics object to update
 * @param campaignQuery - Original campaign query
 * @param shipGroupMap - Map of ship group stats
 * @param characterKillsMap - Map of character kill stats
 * @param characterDamageMap - Map of character damage stats
 * @param trackedKillmails - Set of tracked killmail IDs
 * @param trackedForStats - Set of tracked killmail IDs for stats consistency
 * @param killmailIds - Array to store killmail IDs
 * @param killmailIdIndex - Starting index for killmail IDs
 */
async function processKillmailBatch(
    batch: IKillmail[],
    stats: ICampaignOutput,
    campaignQuery: ICampaign['query'],
    shipGroupMap: Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    trackedKillmails: Set<number>,
    trackedForStats: Set<number>,
    killmailIds: number[],
    killmailIdIndex: number
): Promise<void> {
    let localIndex = killmailIdIndex;

    for (const km of batch) {
        if (!km.victim || !km.attackers || km.attackers.length === 0) continue;

        // Store the killmail ID directly in array at the calculated position
        if (km.killmail_id) {
            killmailIds[localIndex++] = km.killmail_id;
        }

        // Process attacker and victim side determination in parallel
        const [victimOnAttackerSide, victimOnVictimSide, attackersOnAttackerSide, attackersOnVictimSide] = await Promise.all([
            isAttackerSide(km.victim, campaignQuery),
            isVictimSide(km.victim, campaignQuery),
            (async () => km.attackers.some(att => isAttackerSide(att, campaignQuery)))(),
            (async () => km.attackers.some(att => isVictimSide(att, campaignQuery)))()
        ]);

        if (stats.attackerVsVictim) {
            // Attribution logic for kills, losses and ISK damage
            if (attackersOnAttackerSide && !victimOnAttackerSide) {
                // Attackers killed a non-attacker entity
                stats.totalKills++;
                stats.iskDamageDoneAttacker += km.total_value || 0;

                // Add to tracked killmails for stats consistency
                if (!trackedForStats.has(km.killmail_id)) {
                    trackedForStats.add(km.killmail_id);
                }
            }

            if (victimOnAttackerSide) {
                // An attacker entity was killed
                stats.totalLosses++;
                stats.iskDamageReceivedAttacker += km.total_value || 0;

                // Add to tracked killmails for stats consistency
                if (!trackedForStats.has(km.killmail_id)) {
                    trackedForStats.add(km.killmail_id);
                }
            }

            if (attackersOnVictimSide && !victimOnVictimSide) {
                // Victim entities killed a non-victim entity
                stats.iskDamageDoneVictim += km.total_value || 0;
            }
        } else { // General Tracking - count all kills
            stats.totalKills++;
            stats.iskDamageDoneAttacker += km.total_value || 0;
        }

        // Process ship group stats and character stats
        await Promise.all([
            processShipGroupStat(km, stats, shipGroupMap, victimOnAttackerSide, attackersOnAttackerSide),
            processCharacterStats(km, stats, characterKillsMap, characterDamageMap, campaignQuery, trackedKillmails, victimOnAttackerSide, attackersOnAttackerSide)
        ]);
    }
}

/**
 * Process ship group statistics for a killmail
 */
async function processShipGroupStat(
    km: IKillmail,
    stats: ICampaignOutput,
    shipGroupMap: Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean
): Promise<void> {
    const victimShipGroupName = km.victim.ship_group_name || { en: 'Unknown Ship Group' };
    const victimShipGroupNameKey = typeof victimShipGroupName === 'object'
        ? (victimShipGroupName.en || Object.values(victimShipGroupName)[0] || 'Unknown Ship Group')
        : victimShipGroupName;

    let shipStat = shipGroupMap.get(victimShipGroupNameKey);
    if (!shipStat) {
        shipStat = {
            ship_group_id: km.victim.ship_group_id || 0,
            ship_group_name: victimShipGroupName,
            killed: 0,
            lost: 0,
        };
        shipGroupMap.set(victimShipGroupNameKey, shipStat);
    }

    if (stats.attackerVsVictim) {
        if (victimOnAttackerSide) { // Lost by attacker side
            shipStat.lost++;
        } else if (attackersOnAttackerSide) { // Killed by attacker side
            shipStat.killed++;
        }
    } else { // General Tracking
        shipStat.killed++; // All losses are "kills" from campaign perspective
    }
}

/**
 * Process character statistics for a killmail
 */
async function processCharacterStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    campaignQuery: ICampaign['query'],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean
): Promise<void> {
    // Process killer attribution and damage in parallel
    await Promise.all([
        processKillerAttribution(km, stats, characterKillsMap, campaignQuery, trackedKillmails, victimOnAttackerSide, attackersOnAttackerSide),
        processDamageStats(km, stats, characterDamageMap, campaignQuery)
    ]);
}

/**
 * Process killer attribution for a killmail
 */
async function processKillerAttribution(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    campaignQuery: ICampaign['query'],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean
): Promise<void> {
    if (attackersOnAttackerSide && !victimOnAttackerSide && stats.attackerVsVictim) {
        // This killmail represents a kill by the attacker side
        // First try to attribute to final blow if they're on attacker side
        let finalBlowAttacker = km.attackers.find(a => a.is_final_blow && isAttackerSide(a, campaignQuery));

        // If no final blow attacker on attacker side, find the top damage dealer on attacker side
        if (!finalBlowAttacker) {
            finalBlowAttacker = km.attackers
                .filter(a => isAttackerSide(a, campaignQuery))
                .sort((a, b) => (b.damage_done || 0) - (a.damage_done || 0))[0];
        }

        // If we have a valid attacker to attribute the kill to
        if (finalBlowAttacker && finalBlowAttacker.character_id) {
            let killerStat = characterKillsMap.get(finalBlowAttacker.character_id);
            if (!killerStat) {
                killerStat = {
                    character_id: finalBlowAttacker.character_id,
                    character_name: finalBlowAttacker.character_name || 'Unknown Character',
                    kills: 0,
                };
                characterKillsMap.set(finalBlowAttacker.character_id, killerStat);
            }

            // Only increment if we haven't counted this killmail for this character
            if (!trackedKillmails.has(km.killmail_id)) {
                killerStat.kills++;
                trackedKillmails.add(km.killmail_id);
            }
        }
    } else if (!stats.attackerVsVictim) {
        // General tracking - attribute kill to the final blow attacker
        const finalBlowAttacker = km.attackers.find(a => a.is_final_blow);

        if (finalBlowAttacker && finalBlowAttacker.character_id) {
            let killerStat = characterKillsMap.get(finalBlowAttacker.character_id);
            if (!killerStat) {
                killerStat = {
                    character_id: finalBlowAttacker.character_id,
                    character_name: finalBlowAttacker.character_name || 'Unknown Character',
                    kills: 0,
                };
                characterKillsMap.set(finalBlowAttacker.character_id, killerStat);
            }

            // Only increment if we haven't counted this killmail for this character
            if (!trackedKillmails.has(km.killmail_id)) {
                killerStat.kills++;
                trackedKillmails.add(km.killmail_id);
            }
        }
    }
}

/**
 * Process damage statistics for a killmail
 */
async function processDamageStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    campaignQuery: ICampaign['query']
): Promise<void> {
    // Process all attackers in parallel for damage stats
    await Promise.all(km.attackers.map(async (attacker) => {
        if (!attacker.character_id || attacker.damage_done === 0) return;

        if (stats.attackerVsVictim) {
            // Only count damage for attackers on the attacker side
            if (await isAttackerSide(attacker, campaignQuery)) {
                let damageDealerStat = characterDamageMap.get(attacker.character_id);
                if (!damageDealerStat) {
                    damageDealerStat = {
                        character_id: attacker.character_id,
                        character_name: attacker.character_name || 'Unknown Character',
                        damageDone: 0,
                    };
                    characterDamageMap.set(attacker.character_id, damageDealerStat);
                }
                damageDealerStat.damageDone += attacker.damage_done || 0;
            }
        } else { // General Tracking
            let damageDealerStat = characterDamageMap.get(attacker.character_id);
            if (!damageDealerStat) {
                damageDealerStat = {
                    character_id: attacker.character_id,
                    character_name: attacker.character_name || 'Unknown Character',
                    damageDone: 0,
                };
                characterDamageMap.set(attacker.character_id, damageDealerStat);
            }
            damageDealerStat.damageDone += attacker.damage_done || 0;
        }
    }));
}
