import { createError } from 'h3';
import { type ICampaign } from '~/server/interfaces/ICampaign';
import { type ICampaignOutput } from '~/server/interfaces/ICampaignOutput';
import { type IKillmail } from '~/server/interfaces/IKillmail';
import { type ITranslation } from '~/server/interfaces/ITranslation';
import { Campaigns } from '~/server/models/Campaigns';
import { Killmails } from '~/server/models/Killmails';

/**
 * Interface for the statistics generated by the campaign helper.
 * @deprecated Use ICampaignOutput from '~/server/interfaces/ICampaignOutput' instead
 */
export interface ICampaignStatsOutput extends ICampaignOutput { }

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "attacker side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the attacker side, false otherwise.
 */
function isAttackerSide(
    entity: IKillmail['attackers'][0] | IKillmail['victim'],
    campaignQuery: ICampaign['query'],
): boolean {
    // Check direct attacker conditions
    if ('character_id' in entity && campaignQuery['attackers.character_id']) {
        const queryVal = campaignQuery['attackers.character_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if ('corporation_id' in entity && campaignQuery['attackers.corporation_id']) {
        const queryVal = campaignQuery['attackers.corporation_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ('alliance_id' in entity && campaignQuery['attackers.alliance_id']) {
        const queryVal = campaignQuery['attackers.alliance_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ('faction_id' in entity && campaignQuery['attackers.faction_id']) {
        const queryVal = campaignQuery['attackers.faction_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "victim side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the victim side, false otherwise.
 */
function isVictimSide(
    entity: IKillmail['attackers'][0] | IKillmail['victim'],
    campaignQuery: ICampaign['query'],
): boolean {
    // Check direct victim conditions
    if ('character_id' in entity && campaignQuery['victim.character_id']) {
        const queryVal = campaignQuery['victim.character_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if ('corporation_id' in entity && campaignQuery['victim.corporation_id']) {
        const queryVal = campaignQuery['victim.corporation_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ('alliance_id' in entity && campaignQuery['victim.alliance_id']) {
        const queryVal = campaignQuery['victim.alliance_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ('faction_id' in entity && campaignQuery['victim.faction_id']) {
        const queryVal = campaignQuery['victim.faction_id'];
        if (typeof queryVal === 'object' && queryVal !== null && '$in' in queryVal) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Transforms the campaign query into an expanded MongoDB query that properly handles
 * attackers and victims being on either side of the engagement.
 * @param campaignQuery - The original campaign query
 * @returns The expanded MongoDB query
 */
function buildExpandedQuery(campaignQuery: ICampaign['query']): Record<string, any> {
    const expandedQuery: Record<string, any> = {};
    const conditions: any[] = [];

    // Extract entity IDs for potential cross-referencing
    const attackerEntities: Record<string, any> = {};
    const victimEntities: Record<string, any> = {};

    // Process each key in the original query
    Object.entries(campaignQuery).forEach(([key, value]) => {
        // Handle time range and region directly - these don't need expansion
        if (key === 'kill_time' || key === 'region_id' || key === 'system_id' || key === 'constellation_id') {
            expandedQuery[key] = value;
            return;
        }

        // Process attacker entities
        if (key.startsWith('attackers.')) {
            const entityType = key.replace('attackers.', '');
            attackerEntities[entityType] = value;
        }

        // Process victim entities
        else if (key.startsWith('victim.')) {
            const entityType = key.replace('victim.', '');
            victimEntities[entityType] = value;
        }
    });

    // Build OR conditions for attackers
    Object.entries(attackerEntities).forEach(([entityType, entityValue]) => {
        // Create conditions for both attacker and victim roles
        if (typeof entityValue === 'object' && entityValue !== null && '$in' in entityValue) {
            // Handle $in operator
            conditions.push({ [`attackers.${entityType}`]: entityValue });
            // No need to add victim condition for $in as we'll handle this separately
        } else {
            // Direct equality
            conditions.push({ [`attackers.${entityType}`]: entityValue });
        }
    });

    // Build OR conditions for victims
    Object.entries(victimEntities).forEach(([entityType, entityValue]) => {
        // Create conditions for both attacker and victim roles
        if (typeof entityValue === 'object' && entityValue !== null && '$in' in entityValue) {
            // Handle $in operator
            conditions.push({ [`victim.${entityType}`]: entityValue });
        } else {
            // Direct equality
            conditions.push({ [`victim.${entityType}`]: entityValue });
        }
    });

    // Add the OR conditions to the query if we have any
    if (conditions.length > 0) {
        expandedQuery.$or = conditions;
    }

    return expandedQuery;
}

/**
 * Generates aggregated statistics for a campaign based on its ID.
 * @param campaignId - The unique identifier of the campaign.
 * @returns An object containing the campaign statistics.
 */
export async function generateCampaignStats(
    campaignId: string
): Promise<ICampaignOutput> {
    // Fetch the campaign data
    const campaign = await Campaigns.findOne({ campaign_id: campaignId }).lean();

    if (!campaign) {
        throw createError({
            statusCode: 404,
            statusMessage: 'Campaign not found',
        });
    }

    // Create an expanded query that handles attacker and victim entities properly
    const campaignQuery = campaign.query;
    const expandedQuery = buildExpandedQuery(campaignQuery);

    // Apply time constraints if not already included in the query
    if (!expandedQuery.kill_time) {
        expandedQuery.kill_time = {};
        if (campaign.startTime) {
            expandedQuery.kill_time.$gte = new Date(campaign.startTime);
        }
        if (campaign.endTime) {
            expandedQuery.kill_time.$lte = new Date(campaign.endTime);
        }
    }

    // Calculate runtime days in parallel with fetching killmails
    // Always calculate runtime from start time to current date, regardless of end time
    const runtimeDaysPromise = (async () => {
        const campaignStartTimeMs = new Date(campaign.startTime).getTime();
        const currentTimeMs = Date.now();
        return Math.floor((currentTimeMs - campaignStartTimeMs) / (1000 * 60 * 60 * 24));
    })();

    // Fetch all killmails using the expanded query
    const killmailsPromise = Killmails.find(expandedQuery).lean();

    // Wait for both operations to complete in parallel
    const [runtimeDays, relevantKillmails] = await Promise.all([runtimeDaysPromise, killmailsPromise]);

    const stats: ICampaignOutput = {
        // Include campaign metadata
        name: campaign.name,
        description: campaign.description,
        startTime: new Date(campaign.startTime),
        endTime: campaign.endTime ? new Date(campaign.endTime) : undefined,
        creator_id: campaign.creator_id,

        // Initialize statistics
        totalKills: 0,
        totalLosses: 0,
        iskDamageDoneAttacker: 0,
        iskDamageDoneVictim: 0,
        iskDamageReceivedAttacker: 0,
        iskDamageReceivedVictim: 0,
        runtimeDays,
        efficiency: 0,
        attackerVsVictim: false,
        shipGroupStats: [],
        topKillersByCharacter: [],
        topDamageDealersByCharacter: [],
        killmailIds: [],
    };

    // Determine if this is an attacker vs victim campaign
    stats.attackerVsVictim = Object.keys(campaignQuery).some(key =>
        key.startsWith('attackers.') || key.startsWith('victim.')
    );

    // Initialize aggregation maps
    const shipGroupMap = new Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>();
    const characterKillsMap = new Map<number, { character_id: number; character_name: string; kills: number }>();
    const characterDamageMap = new Map<number, { character_id: number; character_name: string; damageDone: number }>();

    // Track unique kills by killmail_id to prevent double counting
    const trackedKillmails = new Set<number>();

    // Collect all killmail IDs without limiting
    const killmailIds: number[] = [];

    // Optimization: Process killmails in batches to avoid blocking the event loop
    const BATCH_SIZE = 500;
    const killmailBatches = [];

    for (let i = 0; i < relevantKillmails.length; i += BATCH_SIZE) {
        killmailBatches.push(relevantKillmails.slice(i, i + BATCH_SIZE));
    }

    console.log(`Processing ${relevantKillmails.length} killmails in ${killmailBatches.length} batches`);

    // Process each batch
    let killmailIdIndex = 0;

    // Using Promise.all to process batches in parallel, with internal sequential processing
    await Promise.all(killmailBatches.map(async (batch, batchIndex) => {
        return processKillmailBatch(
            batch,
            stats,
            campaignQuery,
            shipGroupMap,
            characterKillsMap,
            characterDamageMap,
            trackedKillmails,
            killmailIds,
            killmailIdIndex + (batchIndex * BATCH_SIZE)
        );
    }));

    // Perform final calculations in parallel
    const [shipGroupStats, topKillers, topDamageDealers] = await Promise.all([
        (async () => Array.from(shipGroupMap.values()))(),
        (async () => Array.from(characterKillsMap.values())
            .sort((a, b) => b.kills - a.kills)
            .slice(0, 10))(),
        (async () => Array.from(characterDamageMap.values())
            .sort((a, b) => b.damageDone - a.damageDone)
            .slice(0, 10))()
    ]);

    // Calculate efficiency
    if (stats.attackerVsVictim && stats.iskDamageReceivedAttacker > 0) {
        stats.efficiency = stats.iskDamageDoneAttacker / stats.iskDamageReceivedAttacker;
    } else {
        stats.efficiency = 0;
    }

    // Include ALL killmail IDs without filtering
    stats.killmailIds = killmailIds.filter(id => id !== undefined && id !== null);
    stats.shipGroupStats = shipGroupStats;
    stats.topKillersByCharacter = topKillers;
    stats.topDamageDealersByCharacter = topDamageDealers;

    return stats;
}

/**
 * Process a batch of killmails to update statistics
 * @param batch - Batch of killmails to process
 * @param stats - Statistics object to update
 * @param campaignQuery - Original campaign query
 * @param shipGroupMap - Map of ship group stats
 * @param characterKillsMap - Map of character kill stats
 * @param characterDamageMap - Map of character damage stats
 * @param trackedKillmails - Set of tracked killmail IDs
 * @param killmailIds - Array to store killmail IDs
 * @param killmailIdIndex - Starting index for killmail IDs
 */
async function processKillmailBatch(
    batch: IKillmail[],
    stats: ICampaignOutput,
    campaignQuery: ICampaign['query'],
    shipGroupMap: Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    trackedKillmails: Set<number>,
    killmailIds: number[],
    killmailIdIndex: number
): Promise<void> {
    let localIndex = killmailIdIndex;

    for (const km of batch) {
        if (!km.victim || !km.attackers || km.attackers.length === 0) continue;

        // Store the killmail ID directly in array at the calculated position
        if (km.killmail_id) {
            killmailIds[localIndex++] = km.killmail_id;
        }

        // Process attacker and victim side determination in parallel
        const [victimOnAttackerSide, victimOnVictimSide, attackersOnAttackerSide, attackersOnVictimSide] = await Promise.all([
            isAttackerSide(km.victim, campaignQuery),
            isVictimSide(km.victim, campaignQuery),
            (async () => km.attackers.some(att => isAttackerSide(att, campaignQuery)))(),
            (async () => km.attackers.some(att => isVictimSide(att, campaignQuery)))()
        ]);

        if (stats.attackerVsVictim) {
            // Attribution logic for kills, losses and ISK damage
            if (attackersOnAttackerSide && !victimOnAttackerSide) {
                // Attackers killed a non-attacker entity
                stats.totalKills++;
                stats.iskDamageDoneAttacker += km.total_value || 0;

                // If victim was on victim side, count as ISK damage received by victim side
                if (victimOnVictimSide) {
                    stats.iskDamageReceivedVictim += km.total_value || 0;
                }
            }

            if (victimOnAttackerSide) {
                // An attacker entity was killed
                stats.totalLosses++;
                stats.iskDamageReceivedAttacker += km.total_value || 0;

                // If attackers were on victim side, count as ISK damage done by victim side
                if (attackersOnVictimSide) {
                    stats.iskDamageDoneVictim += km.total_value || 0;
                }
            }

            if (attackersOnVictimSide && !victimOnVictimSide) {
                // Victim entities killed a non-victim entity
                stats.iskDamageDoneVictim += km.total_value || 0;
            }
        } else { // General Tracking - count all kills
            stats.totalKills++;
            stats.iskDamageDoneAttacker += km.total_value || 0;
        }

        // Process ship group stats and character stats
        await Promise.all([
            processShipGroupStat(km, stats, shipGroupMap, victimOnAttackerSide, attackersOnAttackerSide),
            processCharacterStats(km, stats, characterKillsMap, characterDamageMap, campaignQuery, trackedKillmails, victimOnAttackerSide, attackersOnAttackerSide)
        ]);
    }
}

/**
 * Process ship group statistics for a killmail
 */
async function processShipGroupStat(
    km: IKillmail,
    stats: ICampaignOutput,
    shipGroupMap: Map<string, { ship_group_id: number; ship_group_name: string | ITranslation; killed: number; lost: number }>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean
): Promise<void> {
    const victimShipGroupName = km.victim.ship_group_name || { en: 'Unknown Ship Group' };
    const victimShipGroupNameKey = typeof victimShipGroupName === 'object'
        ? (victimShipGroupName.en || Object.values(victimShipGroupName)[0] || 'Unknown Ship Group')
        : victimShipGroupName;

    let shipStat = shipGroupMap.get(victimShipGroupNameKey);
    if (!shipStat) {
        shipStat = {
            ship_group_id: km.victim.ship_group_id || 0,
            ship_group_name: victimShipGroupName,
            killed: 0,
            lost: 0,
        };
        shipGroupMap.set(victimShipGroupNameKey, shipStat);
    }

    if (stats.attackerVsVictim) {
        if (victimOnAttackerSide) { // Lost by attacker side
            shipStat.lost++;
        } else if (attackersOnAttackerSide) { // Killed by attacker side
            shipStat.killed++;
        }
    } else { // General Tracking
        shipStat.killed++; // All losses are "kills" from campaign perspective
    }
}

/**
 * Process character statistics for a killmail
 */
async function processCharacterStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    campaignQuery: ICampaign['query'],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean
): Promise<void> {
    // Process killer attribution and damage in parallel
    await Promise.all([
        processKillerAttribution(km, stats, characterKillsMap, campaignQuery, trackedKillmails, victimOnAttackerSide, attackersOnAttackerSide),
        processDamageStats(km, stats, characterDamageMap, campaignQuery)
    ]);
}

/**
 * Process killer attribution for a killmail
 */
async function processKillerAttribution(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<number, { character_id: number; character_name: string; kills: number }>,
    campaignQuery: ICampaign['query'],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean
): Promise<void> {
    if (attackersOnAttackerSide && !victimOnAttackerSide && stats.attackerVsVictim) {
        // This killmail represents a kill by the attacker side
        // First try to attribute to final blow if they're on attacker side
        let finalBlowAttacker = km.attackers.find(a => a.is_final_blow && isAttackerSide(a, campaignQuery));

        // If no final blow attacker on attacker side, find the top damage dealer on attacker side
        if (!finalBlowAttacker) {
            finalBlowAttacker = km.attackers
                .filter(a => isAttackerSide(a, campaignQuery))
                .sort((a, b) => (b.damage_done || 0) - (a.damage_done || 0))[0];
        }

        // If we have a valid attacker to attribute the kill to
        if (finalBlowAttacker && finalBlowAttacker.character_id) {
            let killerStat = characterKillsMap.get(finalBlowAttacker.character_id);
            if (!killerStat) {
                killerStat = {
                    character_id: finalBlowAttacker.character_id,
                    character_name: finalBlowAttacker.character_name || 'Unknown Character',
                    kills: 0,
                };
                characterKillsMap.set(finalBlowAttacker.character_id, killerStat);
            }

            // Only increment if we haven't counted this killmail for this character
            if (!trackedKillmails.has(km.killmail_id)) {
                killerStat.kills++;
                trackedKillmails.add(km.killmail_id);
            }
        }
    } else if (!stats.attackerVsVictim) {
        // General tracking - attribute kill to the final blow attacker
        const finalBlowAttacker = km.attackers.find(a => a.is_final_blow);

        if (finalBlowAttacker && finalBlowAttacker.character_id) {
            let killerStat = characterKillsMap.get(finalBlowAttacker.character_id);
            if (!killerStat) {
                killerStat = {
                    character_id: finalBlowAttacker.character_id,
                    character_name: finalBlowAttacker.character_name || 'Unknown Character',
                    kills: 0,
                };
                characterKillsMap.set(finalBlowAttacker.character_id, killerStat);
            }

            // Only increment if we haven't counted this killmail for this character
            if (!trackedKillmails.has(km.killmail_id)) {
                killerStat.kills++;
                trackedKillmails.add(km.killmail_id);
            }
        }
    }
}

/**
 * Process damage statistics for a killmail
 */
async function processDamageStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterDamageMap: Map<number, { character_id: number; character_name: string; damageDone: number }>,
    campaignQuery: ICampaign['query']
): Promise<void> {
    // Process all attackers in parallel for damage stats
    await Promise.all(km.attackers.map(async (attacker) => {
        if (!attacker.character_id || attacker.damage_done === 0) return;

        if (stats.attackerVsVictim) {
            // Only count damage for attackers on the attacker side
            if (await isAttackerSide(attacker, campaignQuery)) {
                let damageDealerStat = characterDamageMap.get(attacker.character_id);
                if (!damageDealerStat) {
                    damageDealerStat = {
                        character_id: attacker.character_id,
                        character_name: attacker.character_name || 'Unknown Character',
                        damageDone: 0,
                    };
                    characterDamageMap.set(attacker.character_id, damageDealerStat);
                }
                damageDealerStat.damageDone += attacker.damage_done || 0;
            }
        } else { // General Tracking
            let damageDealerStat = characterDamageMap.get(attacker.character_id);
            if (!damageDealerStat) {
                damageDealerStat = {
                    character_id: attacker.character_id,
                    character_name: attacker.character_name || 'Unknown Character',
                    damageDone: 0,
                };
                characterDamageMap.set(attacker.character_id, damageDealerStat);
            }
            damageDealerStat.damageDone += attacker.damage_done || 0;
        }
    }));
}
