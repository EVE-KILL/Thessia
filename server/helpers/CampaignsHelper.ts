import { createError } from "h3";
import { type ICampaign } from "~/server/interfaces/ICampaign";
import {
    type ICampaignFilterEntities,
    type ICampaignOutput,
} from "~/server/interfaces/ICampaignOutput";
import { type IKillmail } from "~/server/interfaces/IKillmail";
import { type ITranslation } from "~/server/interfaces/ITranslation";
import { Alliances } from "~/server/models/Alliances";
import { Campaigns } from "~/server/models/Campaigns";
import { Characters } from "~/server/models/Characters";
import { Constellations } from "~/server/models/Constellations";
import { Corporations } from "~/server/models/Corporations";
import { Factions } from "~/server/models/Factions";
import { Killmails } from "~/server/models/Killmails";
import { Regions } from "~/server/models/Regions";
import { SolarSystems } from "~/server/models/SolarSystems";

/**
 * Interface for the statistics generated by the campaign helper.
 * @deprecated Use ICampaignOutput from '~/server/interfaces/ICampaignOutput' instead
 */
export interface ICampaignStatsOutput extends ICampaignOutput {}

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "attacker side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the attacker side, false otherwise.
 */
function isAttackerSide(
    entity: IKillmail["attackers"][0] | IKillmail["victim"],
    campaignQuery: ICampaign["query"]
): boolean {
    // Ensure entity exists and has required properties
    if (!entity) return false;
    
    // Check direct attacker conditions
    if ("character_id" in entity && entity.character_id && campaignQuery["attackers.character_id"]) {
        const queryVal = campaignQuery["attackers.character_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if (
        "corporation_id" in entity &&
        entity.corporation_id &&
        campaignQuery["attackers.corporation_id"]
    ) {
        const queryVal = campaignQuery["attackers.corporation_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ("alliance_id" in entity && entity.alliance_id && campaignQuery["attackers.alliance_id"]) {
        const queryVal = campaignQuery["attackers.alliance_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ("faction_id" in entity && entity.faction_id && campaignQuery["attackers.faction_id"]) {
        const queryVal = campaignQuery["attackers.faction_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Helper function to determine if an entity (attacker or victim) is part of the "victim side"
 * as defined by the campaign query.
 * @param entity - The killmail attacker or victim object.
 * @param campaignQuery - The campaign query object.
 * @returns True if the entity is on the victim side, false otherwise.
 */
function isVictimSide(
    entity: IKillmail["attackers"][0] | IKillmail["victim"],
    campaignQuery: ICampaign["query"]
): boolean {
    // Ensure entity exists and has required properties
    if (!entity) return false;
    
    // Check direct victim conditions
    if ("character_id" in entity && entity.character_id && campaignQuery["victim.character_id"]) {
        const queryVal = campaignQuery["victim.character_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.character_id)) return true;
        } else if (entity.character_id === queryVal) {
            return true;
        }
    }
    if ("corporation_id" in entity && entity.corporation_id && campaignQuery["victim.corporation_id"]) {
        const queryVal = campaignQuery["victim.corporation_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.corporation_id)) return true;
        } else if (entity.corporation_id === queryVal) {
            return true;
        }
    }
    if ("alliance_id" in entity && entity.alliance_id && campaignQuery["victim.alliance_id"]) {
        const queryVal = campaignQuery["victim.alliance_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.alliance_id)) return true;
        } else if (entity.alliance_id === queryVal) {
            return true;
        }
    }
    if ("faction_id" in entity && entity.faction_id && campaignQuery["victim.faction_id"]) {
        const queryVal = campaignQuery["victim.faction_id"];
        if (
            typeof queryVal === "object" &&
            queryVal !== null &&
            "$in" in queryVal
        ) {
            if (queryVal.$in.includes(entity.faction_id)) return true;
        } else if (entity.faction_id === queryVal) {
            return true;
        }
    }

    return false;
}

/**
 * Transforms the campaign query into an expanded MongoDB query that respects
 * role separation - attackers remain attackers, victims remain victims.
 * @param campaignQuery - The original campaign query
 * @returns The expanded MongoDB query
 */
export function buildExpandedQuery(
    campaignQuery: ICampaign["query"]
): Record<string, any> {
    const expandedQuery: Record<string, any> = {};

    // Extract location and time filters
    const locationTimeFilters: Record<string, any> = {};

    // Process location and time filters
    ["region_id", "system_id", "constellation_id", "kill_time"].forEach(
        (key) => {
            if (campaignQuery[key]) {
                locationTimeFilters[key] = campaignQuery[key];
            }
        }
    );

    // Apply location and time filters directly to the main query
    Object.assign(expandedQuery, locationTimeFilters);

    // Separate attacker and victim entity specifications
    const attackerSpecs: Record<string, any> = {};
    const victimSpecs: Record<string, any> = {};

    // Collect attacker and victim specifications
    Object.entries(campaignQuery).forEach(([key, value]) => {
        if (key.startsWith("attackers.")) {
            attackerSpecs[key] = value;
        } else if (key.startsWith("victim.")) {
            victimSpecs[key] = value;
        }
    });

    const hasAttackerSpecs = Object.keys(attackerSpecs).length > 0;
    const hasVictimSpecs = Object.keys(victimSpecs).length > 0;

    // Handle different filter scenarios
    if (hasAttackerSpecs && hasVictimSpecs) {
        // Both attacker and victim specs are present - build a strict directional query
        const strictDirectionalQuery = buildStrictDirectionalQuery(
            attackerSpecs,
            victimSpecs
        );
        Object.assign(expandedQuery, strictDirectionalQuery);
    } else if (hasAttackerSpecs) {
        // Only attacker specs - build a query that only matches attackers
        const attackerQuery = buildAttackerOnlyQuery(attackerSpecs);
        Object.assign(expandedQuery, attackerQuery);
    } else if (hasVictimSpecs) {
        // Only victim specs - build a query that only matches victims
        const victimQuery = buildVictimOnlyQuery(victimSpecs);
        Object.assign(expandedQuery, victimQuery);
    }

    return expandedQuery;
}

/**
 * Build a bidirectional query that matches when either:
 * - Attackers are attackers and victims are victims, OR
 * - Victims are attackers and attackers are victims (reverse direction)
 * @param attackerSpecs - Specifications for the attacker side
 * @param victimSpecs - Specifications for the victim side
 * @returns Query object that matches bidirectional engagement
 */
function buildStrictDirectionalQuery(
    attackerSpecs: Record<string, any>,
    victimSpecs: Record<string, any>
): Record<string, any> {
    // Build query components for both directions
    const attackerSideAttacks = buildDirectionalMatchQuery(
        attackerSpecs,
        "attackers."
    );
    const victimSideAsVictim = buildDirectionalMatchQuery(
        victimSpecs,
        "victim."
    );

    // Build reverse direction components
    const victimSideAttacks = buildDirectionalMatchQuery(
        victimSpecs,
        "attackers."
    );
    const attackerSideAsVictim = buildDirectionalMatchQuery(
        attackerSpecs,
        "victim."
    );

    // Match either direction: (Attackers attack Victims) OR (Victims attack Attackers)
    return {
        $or: [
            // Direction 1: Attacker side attacks victim side
            {
                $and: [attackerSideAttacks, victimSideAsVictim],
            },
            // Direction 2: Victim side attacks attacker side
            {
                $and: [victimSideAttacks, attackerSideAsVictim],
            },
        ],
    };
}

/**
 * Build a query component that matches entities from specs in the given field prefix
 * @param specs - Entity specifications (attacker or victim)
 * @param fieldPrefix - Field prefix to match against ('attackers.' or 'victim.')
 * @returns Query object that matches entities in the specified fields
 */
function buildDirectionalMatchQuery(
    specs: Record<string, any>,
    fieldPrefix: "attackers." | "victim."
): Record<string, any> {
    const conditions: Record<string, any>[] = [];

    // Group specs by entity type for more efficient queries
    const entityTypeGroups: Record<string, any[]> = {};

    Object.entries(specs).forEach(([key, value]) => {
        // Extract entity type (e.g., 'character_id', 'corporation_id')
        const entityType = key.replace("attackers.", "").replace("victim.", "");

        if (!entityTypeGroups[entityType]) {
            entityTypeGroups[entityType] = [];
        }

        // Determine the field to match against based on prefix and entity type
        const matchField = `${fieldPrefix}${entityType}`;

        // Handle different value types ($in arrays or direct values)
        if (typeof value === "object" && value !== null && "$in" in value) {
            conditions.push({ [matchField]: { $in: value.$in } });
        } else {
            conditions.push({ [matchField]: value });
        }
    });

    // For single condition, return it directly
    if (conditions.length === 1) {
        return conditions[0];
    }

    // For multiple conditions, use $or to match any of them
    return { $or: conditions };
}

/**
 * Build a query that only matches entities as attackers
 * @param specs - Entity specifications for attackers
 * @returns Query object that matches entities only in attacker role
 */
function buildAttackerOnlyQuery(
    specs: Record<string, any>
): Record<string, any> {
    return buildDirectionalMatchQuery(specs, "attackers.");
}

/**
 * Build a query that only matches entities as victims
 * @param specs - Entity specifications for victims
 * @returns Query object that matches entities only in victim role
 */
function buildVictimOnlyQuery(specs: Record<string, any>): Record<string, any> {
    return buildDirectionalMatchQuery(specs, "victim.");
}

/**
 * Process campaign query and resolve entity IDs to names
 * @param campaignQuery - The campaign query object
 * @returns Object containing resolved entity data for the UI
 */
export async function processQueryForUI(
    campaignQuery: ICampaign["query"]
): Promise<ICampaignFilterEntities> {
    // Initialize the filter entities object
    const filterEntities: ICampaignFilterEntities = {
        regions: [],
        constellations: [],
        systems: [],
        attackerCharacters: [],
        attackerCorporations: [],
        attackerAlliances: [],
        attackerFactions: [],
        victimCharacters: [],
        victimCorporations: [],
        victimAlliances: [],
        victimFactions: [],
    };

    // Process each filter type in parallel for performance
    await Promise.all([
        // Process locations
        processRegionIds(campaignQuery["region_id"], filterEntities),
        processConstellationIds(
            campaignQuery["constellation_id"],
            filterEntities
        ),
        processSystemIds(campaignQuery["system_id"], filterEntities),

        // Process attacker entities
        processCharacterIds(
            campaignQuery["attackers.character_id"],
            filterEntities,
            "attackerCharacters"
        ),
        processCorporationIds(
            campaignQuery["attackers.corporation_id"],
            filterEntities,
            "attackerCorporations"
        ),
        processAllianceIds(
            campaignQuery["attackers.alliance_id"],
            filterEntities,
            "attackerAlliances"
        ),
        processFactionIds(
            campaignQuery["attackers.faction_id"],
            filterEntities,
            "attackerFactions"
        ),

        // Process victim entities
        processCharacterIds(
            campaignQuery["victim.character_id"],
            filterEntities,
            "victimCharacters"
        ),
        processCorporationIds(
            campaignQuery["victim.corporation_id"],
            filterEntities,
            "victimCorporations"
        ),
        processAllianceIds(
            campaignQuery["victim.alliance_id"],
            filterEntities,
            "victimAlliances"
        ),
        processFactionIds(
            campaignQuery["victim.faction_id"],
            filterEntities,
            "victimFactions"
        ),
    ]);

    return filterEntities;
}

/**
 * Extract IDs from a query field value which may be a single ID or an $in array
 */
function extractIds(fieldValue: any): number[] {
    if (!fieldValue) return [];

    if (
        typeof fieldValue === "object" &&
        fieldValue !== null &&
        "$in" in fieldValue
    ) {
        return Array.isArray(fieldValue.$in) ? fieldValue.$in : [];
    }

    return typeof fieldValue === "number" || typeof fieldValue === "string"
        ? [Number(fieldValue)]
        : [];
}

/**
 * Process region IDs and add to filter entities
 */
async function processRegionIds(
    regionIdField: any,
    filterEntities: ICampaignFilterEntities
): Promise<void> {
    const regionIds = extractIds(regionIdField);
    if (!regionIds.length) return;

    const regions = await Regions.find({
        region_id: { $in: regionIds },
    }).lean();

    filterEntities.regions = regions.map((region) => ({
        id: region.region_id,
        name:
            typeof region.name === "object"
                ? region.name.en ||
                  Object.values(region.name)[0] ||
                  "Unknown Region"
                : region.name || "Unknown Region",
    }));
}

/**
 * Process constellation IDs and add to filter entities
 */
async function processConstellationIds(
    constellationIdField: any,
    filterEntities: ICampaignFilterEntities
): Promise<void> {
    const constellationIds = extractIds(constellationIdField);
    if (!constellationIds.length) return;

    const constellations = await Constellations.find({
        constellation_id: { $in: constellationIds },
    }).lean();

    filterEntities.constellations = constellations.map((constellation) => ({
        id: constellation.constellation_id,
        name: constellation.constellation_name || "Unknown Constellation",
    }));
}

/**
 * Process system IDs and add to filter entities
 */
async function processSystemIds(
    systemIdField: any,
    filterEntities: ICampaignFilterEntities
): Promise<void> {
    const systemIds = extractIds(systemIdField);
    if (!systemIds.length) return;

    const systems = await SolarSystems.find({
        system_id: { $in: systemIds },
    }).lean();

    filterEntities.systems = systems.map((system) => ({
        id: system.system_id,
        name: system.system_name || "Unknown System",
    }));
}

/**
 * Process character IDs and add to filter entities
 */
async function processCharacterIds(
    characterIdField: any,
    filterEntities: ICampaignFilterEntities,
    key: "attackerCharacters" | "victimCharacters"
): Promise<void> {
    const characterIds = extractIds(characterIdField);
    if (!characterIds.length) return;

    const characters = await Characters.find({
        character_id: { $in: characterIds },
    }).lean();

    filterEntities[key] = characters.map((character) => ({
        id: character.character_id,
        name: character.name || "Unknown Character",
    }));
}

/**
 * Process corporation IDs and add to filter entities
 */
async function processCorporationIds(
    corporationIdField: any,
    filterEntities: ICampaignFilterEntities,
    key: "attackerCorporations" | "victimCorporations"
): Promise<void> {
    const corporationIds = extractIds(corporationIdField);
    if (!corporationIds.length) return;

    const corporations = await Corporations.find({
        corporation_id: { $in: corporationIds },
    }).lean();

    filterEntities[key] = corporations.map((corporation) => ({
        id: corporation.corporation_id,
        name: corporation.name || "Unknown Corporation",
    }));
}

/**
 * Process alliance IDs and add to filter entities
 */
async function processAllianceIds(
    allianceIdField: any,
    filterEntities: ICampaignFilterEntities,
    key: "attackerAlliances" | "victimAlliances"
): Promise<void> {
    const allianceIds = extractIds(allianceIdField);
    if (!allianceIds.length) return;

    const alliances = await Alliances.find({
        alliance_id: { $in: allianceIds },
    }).lean();

    filterEntities[key] = alliances.map((alliance) => ({
        id: alliance.alliance_id,
        name: alliance.name || "Unknown Alliance",
    }));
}

/**
 * Process faction IDs and add to filter entities
 */
async function processFactionIds(
    factionIdField: any,
    filterEntities: ICampaignFilterEntities,
    key: "attackerFactions" | "victimFactions"
): Promise<void> {
    const factionIds = extractIds(factionIdField);
    if (!factionIds.length) return;

    const factions = await Factions.find({
        faction_id: { $in: factionIds },
    }).lean();

    filterEntities[key] = factions.map((faction) => ({
        id: faction.faction_id,
        name: faction.name || "Unknown Faction",
    }));
}

/**
 * Generates aggregated statistics for a campaign based on its ID or direct campaign data.
 *
 * For mixed campaigns (both attackers and victims defined), the calculations are split into separate steps:
 * 1. Calculate kills done by attackers vs victims
 * 2. Calculate kills done by victims vs attackers
 * 3. Calculate ISK damage inflicted by attackers vs victims
 * 4. Calculate ISK damage inflicted by victims vs attackers
 * 5. Calculate ships killed by attackers vs victims
 * 6. Calculate ships killed by victims vs attackers
 *
 * The killmail list only includes attackers vs victims kills (not the reverse direction).
 *
 * @param campaignIdOrData - Either the unique identifier of the campaign or complete campaign data object.
 * @returns An object containing the campaign statistics.
 */
export async function generateCampaignStats(
    campaignIdOrData: string | ICampaign
): Promise<ICampaignOutput> {
    // Fetch the campaign data or use provided data directly
    let campaign: ICampaign | null = null;

    if (typeof campaignIdOrData === "string") {
        // Fetch the campaign data using ID
        campaign = await Campaigns.findOne({
            campaign_id: campaignIdOrData,
        }).lean();

        if (!campaign) {
            throw createError({
                statusCode: 404,
                statusMessage: "Campaign not found",
            });
        }
    } else {
        // Use provided data directly
        campaign = campaignIdOrData;
    }

    // Process the campaign query to resolve entity names
    const filterEntities = await processQueryForUI(campaign.query);

    // Create an expanded query that handles attacker and victim entities properly
    const campaignQuery = campaign.query;
    const expandedQuery = buildExpandedQuery(campaignQuery);

    // Apply time constraints if not already included in the query
    if (!expandedQuery.kill_time) {
        expandedQuery.kill_time = {};
        if (campaign.startTime) {
            expandedQuery.kill_time.$gte = new Date(campaign.startTime);
        }
        if (campaign.endTime) {
            expandedQuery.kill_time.$lte = new Date(campaign.endTime);
        }
    }

    // Calculate runtime days in parallel with fetching killmails
    // Always calculate runtime from start time to current date, regardless of end time
    const runtimeDaysPromise = (async () => {
        const campaignStartTimeMs = new Date(campaign.startTime).getTime();
        const currentTimeMs = Date.now();
        return Math.floor(
            (currentTimeMs - campaignStartTimeMs) / (1000 * 60 * 60 * 24)
        );
    })();

    // Fetch all killmails using the expanded query
    const killmailsPromise = (async () => {
        // Force a fresh query execution by cloning the query and using a new cursor
        const queryClone = JSON.parse(JSON.stringify(expandedQuery));
        const results = await Killmails.find(queryClone).lean().exec();
        
        // Additional validation - check for null/undefined values that might cause issues
        const validResults = results.filter(km => 
            km && 
            km.killmail_id && 
            km.victim && 
            km.attackers && 
            Array.isArray(km.attackers) && 
            km.attackers.length > 0
        );
        
        return validResults;
    })();

    // Wait for both operations to complete in parallel
    const [runtimeDays, relevantKillmails] = await Promise.all([
        runtimeDaysPromise,
        killmailsPromise,
    ]);

    const stats: ICampaignOutput = {
        // Include campaign metadata
        name: campaign.name,
        description: campaign.description,
        startTime: new Date(campaign.startTime),
        endTime: campaign.endTime ? new Date(campaign.endTime) : undefined,
        creator_id: campaign.creator_id,
        campaignQuery: campaignQuery,
        filterEntities: filterEntities,

        // Initialize statistics
        totalKills: 0,
        totalLosses: 0,
        iskDamageDoneAttacker: 0,
        iskDamageDoneVictim: 0,
        iskDamageReceivedAttacker: 0,
        iskDamageReceivedVictim: 0,
        runtimeDays,
        efficiency: 0,
        attackerVsVictim: false,
        shipGroupStats: [],
        topKillersByCharacter: [],
        topVictimsByCharacter: [],
        topDamageDealersByCharacter: [],
        topDamageTakersByCharacter: [],
        topKillersByCorporation: [],
        topVictimsByCorporation: [],
        topKillersByAlliance: [],
        topVictimsByAlliance: [],
        mostValuableKills: [],
        killmailIds: [],
    };

    // Determine if this is an attacker vs victim campaign
    stats.attackerVsVictim = Object.keys(campaignQuery).some(
        (key) => key.startsWith("attackers.") || key.startsWith("victim.")
    );

    // Initialize aggregation maps
    const shipGroupMap = new Map<
        string,
        {
            ship_group_id: number;
            ship_group_name: string | ITranslation;
            killed: number;
            lost: number;
        }
    >();
    const characterKillsMap = new Map<
        number,
        { character_id: number; character_name: string; kills: number }
    >();
    const characterLossesMap = new Map<
        number,
        { character_id: number; character_name: string; losses: number }
    >();
    const characterDamageMap = new Map<
        number,
        { character_id: number; character_name: string; damageDone: number }
    >();
    const characterDamageTakenMap = new Map<
        number,
        { character_id: number; character_name: string; damageTaken: number }
    >();

    // Corporation aggregation maps
    const corporationKillsMap = new Map<
        number,
        { corporation_id: number; corporation_name: string; kills: number }
    >();
    const corporationLossesMap = new Map<
        number,
        { corporation_id: number; corporation_name: string; losses: number }
    >();

    // Alliance aggregation maps
    const allianceKillsMap = new Map<
        number,
        { alliance_id: number; alliance_name: string; kills: number }
    >();
    const allianceLossesMap = new Map<
        number,
        { alliance_id: number; alliance_name: string; losses: number }
    >();

    // Most valuable kills tracking
    const mostValuableKillsArray: Array<{
        killmail_id: number;
        total_value: number;
        victim: any;
        final_blow?: any;
    }> = [];

    // Track unique kills by killmail_id to prevent double counting
    const trackedKillmails = new Set<number>();
    const trackedForStats = new Set<number>();

    // Collect all killmail IDs without limiting
    const killmailIds: number[] = [];

    // Optimization: Process killmails in batches to avoid blocking the event loop
    const BATCH_SIZE = 500;
    const killmailBatches = [];

    for (let i = 0; i < relevantKillmails.length; i += BATCH_SIZE) {
        killmailBatches.push(relevantKillmails.slice(i, i + BATCH_SIZE));
    }

    // Process each batch
    let killmailIdIndex = 0;

    // Process batches sequentially to avoid race conditions on shared state
    // The stats object and various Maps/Sets are shared mutable state that cannot be safely
    // modified concurrently by multiple batches
    for (
        let batchIndex = 0;
        batchIndex < killmailBatches.length;
        batchIndex++
    ) {
        const batch = killmailBatches[batchIndex];
        await processKillmailBatch(
            batch,
            stats,
            campaignQuery,
            shipGroupMap,
            characterKillsMap,
            characterLossesMap,
            characterDamageMap,
            characterDamageTakenMap,
            corporationKillsMap,
            corporationLossesMap,
            allianceKillsMap,
            allianceLossesMap,
            mostValuableKillsArray,
            trackedKillmails,
            trackedForStats,
            killmailIds,
            killmailIdIndex + batchIndex * BATCH_SIZE
        );
    }

    // Perform final calculations in parallel
    const [
        shipGroupStats,
        topKillers,
        topVictims,
        topDamageDealers,
        topDamageTakers,
        topKillersCorporations,
        topVictimsCorporations,
        topKillersAlliances,
        topVictimsAlliances,
        mostValuableKills,
    ] = await Promise.all([
        (async () => Array.from(shipGroupMap.values()))(),
        (async () =>
            Array.from(characterKillsMap.values())
                .sort((a, b) => b.kills - a.kills)
                .slice(0, 10))(),
        (async () =>
            Array.from(characterLossesMap.values())
                .sort((a, b) => b.losses - a.losses)
                .slice(0, 10))(),
        (async () =>
            Array.from(characterDamageMap.values())
                .sort((a, b) => b.damageDone - a.damageDone)
                .slice(0, 10))(),
        (async () =>
            Array.from(characterDamageTakenMap.values())
                .sort((a, b) => b.damageTaken - a.damageTaken)
                .slice(0, 10))(),
        (async () =>
            Array.from(corporationKillsMap.values())
                .sort((a, b) => b.kills - a.kills)
                .slice(0, 10))(),
        (async () =>
            Array.from(corporationLossesMap.values())
                .sort((a, b) => b.losses - a.losses)
                .slice(0, 10))(),
        (async () =>
            Array.from(allianceKillsMap.values())
                .sort((a, b) => b.kills - a.kills)
                .slice(0, 10))(),
        (async () =>
            Array.from(allianceLossesMap.values())
                .sort((a, b) => b.losses - a.losses)
                .slice(0, 10))(),
        (async () =>
            mostValuableKillsArray
                .sort((a, b) => b.total_value - a.total_value)
                .slice(0, 10))(),
    ]);

    // Determine what to show in topKillersByCharacter based on campaign type
    const hasAttackerDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("attackers.")
    );
    const hasVictimDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("victim.")
    );

    let topCharacters = topKillers;
    if (hasVictimDefinitions && !hasAttackerDefinitions) {
        // Victim-only campaign: show top victims as "losers" but convert to killers format
        topCharacters = topVictims.map((victim) => ({
            character_id: victim.character_id,
            character_name: victim.character_name,
            kills: victim.losses, // Show losses as "participation"
        }));
    } else if (topKillers.length === 0 && topVictims.length > 0) {
        // Fallback: if no killers data but have victims, show victims
        topCharacters = topVictims.map((victim) => ({
            character_id: victim.character_id,
            character_name: victim.character_name,
            kills: victim.losses,
        }));
    }

    // Calculate efficiency for attacker vs victim campaigns
    if (stats.attackerVsVictim) {
        // Efficiency = ISK damage done by attackers / ISK damage done by victims
        const iskDamageDoneAttacker = stats.iskDamageDoneAttacker || 0;
        const iskDamageDoneVictim = stats.iskDamageDoneVictim || 0;

        if (iskDamageDoneVictim > 0) {
            stats.efficiency = iskDamageDoneAttacker / iskDamageDoneVictim;
        } else if (iskDamageDoneAttacker > 0) {
            // If attackers did damage but victims did none, efficiency is infinite (represented as a large number)
            stats.efficiency = 999999;
        } else {
            // If neither side did damage, efficiency is 0
            stats.efficiency = 0;
        }
    } else {
        stats.efficiency = 0;
    }

    // Include ALL killmail IDs without filtering
    stats.killmailIds = killmailIds.filter(
        (id) => id !== undefined && id !== null
    );
    stats.shipGroupStats = shipGroupStats;
    stats.topKillersByCharacter = topCharacters;
    stats.topVictimsByCharacter = topVictims;
    stats.topDamageDealersByCharacter = topDamageDealers;
    stats.topDamageTakersByCharacter = topDamageTakers;
    stats.topKillersByCorporation = topKillersCorporations;
    stats.topVictimsByCorporation = topVictimsCorporations;
    stats.topKillersByAlliance = topKillersAlliances;
    stats.topVictimsByAlliance = topVictimsAlliances;
    stats.mostValuableKills = mostValuableKills;

    return stats;
}

/**
 * Process a batch of killmails to update statistics
 * @param batch - Batch of killmails to process
 * @param stats - Statistics object to update
 * @param campaignQuery - Original campaign query
 * @param shipGroupMap - Map of ship group stats
 * @param characterKillsMap - Map of character kill stats
 * @param characterLossesMap - Map of character loss stats
 * @param characterDamageMap - Map of character damage stats
 * @param characterDamageTakenMap - Map of character damage taken stats
 * @param corporationKillsMap - Map of corporation kill stats
 * @param corporationLossesMap - Map of corporation loss stats
 * @param allianceKillsMap - Map of alliance kill stats
 * @param allianceLossesMap - Map of alliance loss stats
 * @param mostValuableKillsArray - Array of most valuable kills
 * @param trackedKillmails - Set of tracked killmail IDs
 * @param trackedForStats - Set of tracked killmail IDs for stats consistency
 * @param killmailIds - Array to store killmail IDs
 * @param killmailIdIndex - Starting index for killmail IDs
 */
async function processKillmailBatch(
    batch: IKillmail[],
    stats: ICampaignOutput,
    campaignQuery: ICampaign["query"],
    shipGroupMap: Map<
        string,
        {
            ship_group_id: number;
            ship_group_name: string | ITranslation;
            killed: number;
            lost: number;
        }
    >,
    characterKillsMap: Map<
        number,
        { character_id: number; character_name: string; kills: number }
    >,
    characterLossesMap: Map<
        number,
        { character_id: number; character_name: string; losses: number }
    >,
    characterDamageMap: Map<
        number,
        { character_id: number; character_name: string; damageDone: number }
    >,
    characterDamageTakenMap: Map<
        number,
        { character_id: number; character_name: string; damageTaken: number }
    >,
    corporationKillsMap: Map<
        number,
        { corporation_id: number; corporation_name: string; kills: number }
    >,
    corporationLossesMap: Map<
        number,
        { corporation_id: number; corporation_name: string; losses: number }
    >,
    allianceKillsMap: Map<
        number,
        { alliance_id: number; alliance_name: string; kills: number }
    >,
    allianceLossesMap: Map<
        number,
        { alliance_id: number; alliance_name: string; losses: number }
    >,
    mostValuableKillsArray: Array<{
        killmail_id: number;
        total_value: number;
        victim: any;
        final_blow?: any;
    }>,
    trackedKillmails: Set<number>,
    trackedForStats: Set<number>,
    killmailIds: number[],
    killmailIdIndex: number
): Promise<void> {
    let localIndex = killmailIdIndex;

    for (const km of batch) {
        if (!km.victim || !km.attackers || km.attackers.length === 0) continue;

        // Process attacker and victim side determination in parallel
        const [
            victimOnAttackerSide,
            victimOnVictimSide,
            attackersOnAttackerSide,
            attackersOnVictimSide,
        ] = await Promise.all([
            isAttackerSide(km.victim, campaignQuery),
            isVictimSide(km.victim, campaignQuery),
            (async () =>
                km.attackers.some((att: any) =>
                    isAttackerSide(att, campaignQuery)
                ))(),
            (async () =>
                km.attackers.some((att: any) =>
                    isVictimSide(att, campaignQuery)
                ))(),
        ]);

        // Determine if this killmail should be included in the main killmail list
        let shouldIncludeInKillmailList = false;

        if (stats.attackerVsVictim) {
            const hasAttackerDefinitions = Object.keys(campaignQuery).some(
                (key) => key.startsWith("attackers.")
            );
            const hasVictimDefinitions = Object.keys(campaignQuery).some(
                (key) => key.startsWith("victim.")
            );

            if (hasAttackerDefinitions && hasVictimDefinitions) {
                // Mixed Campaign: Only include attackers vs victims kills in the killmail list
                if (attackersOnAttackerSide && victimOnVictimSide) {
                    shouldIncludeInKillmailList = true;
                }
            } else {
                // Single-side campaigns: include all relevant kills
                if (hasAttackerDefinitions && attackersOnAttackerSide) {
                    shouldIncludeInKillmailList = true;
                } else if (hasVictimDefinitions && victimOnVictimSide) {
                    shouldIncludeInKillmailList = true;
                }
            }
        } else {
            // General campaigns: include all killmails
            shouldIncludeInKillmailList = true;
        }

        // Store the killmail ID only if it should be included in the list
        if (km.killmail_id && shouldIncludeInKillmailList) {
            killmailIds[localIndex++] = km.killmail_id;
        }

        if (stats.attackerVsVictim) {
            // Check if campaign defines any attackers or victims
            const hasAttackerDefinitions = Object.keys(campaignQuery).some(
                (key) => key.startsWith("attackers.")
            );
            const hasVictimDefinitions = Object.keys(campaignQuery).some(
                (key) => key.startsWith("victim.")
            );

            if (hasAttackerDefinitions && hasVictimDefinitions) {
                // Mixed Campaign: Calculate both directions separately for complete statistics

                // Step 1: Calculate kills done by attackers vs victims
                if (attackersOnAttackerSide && victimOnVictimSide) {
                    stats.totalKills++;

                    // Step 3: Calculate ISK damage inflicted by attackers vs victims
                    stats.iskDamageDoneAttacker += km.total_value || 0;
                    stats.iskDamageReceivedVictim += km.total_value || 0;

                    // Only include attackers vs victims kills in the killmail list
                    if (!trackedForStats.has(km.killmail_id)) {
                        trackedForStats.add(km.killmail_id);
                    }
                }

                // Step 2: Calculate kills done by victims vs attackers (for complete stats)
                if (attackersOnVictimSide && victimOnAttackerSide) {
                    stats.totalLosses++;

                    // Step 4: Calculate ISK damage inflicted by victims vs attackers
                    stats.iskDamageDoneVictim += km.total_value || 0;
                    stats.iskDamageReceivedAttacker += km.total_value || 0;

                    // Note: We don't add these to trackedForStats as they shouldn't be in the main killmail list
                }
            } else if (hasAttackerDefinitions && !hasVictimDefinitions) {
                // Attacker-only Campaign: Track only kills by attackers
                if (attackersOnAttackerSide) {
                    stats.totalKills++;
                    stats.iskDamageDoneAttacker += km.total_value || 0;

                    if (!trackedForStats.has(km.killmail_id)) {
                        trackedForStats.add(km.killmail_id);
                    }
                }
            } else if (hasVictimDefinitions && !hasAttackerDefinitions) {
                // Victim-only Campaign: Track only losses of victims
                if (victimOnVictimSide) {
                    stats.totalLosses++;
                    stats.iskDamageReceivedVictim += km.total_value || 0;

                    if (!trackedForStats.has(km.killmail_id)) {
                        trackedForStats.add(km.killmail_id);
                    }
                }
            }
        } else {
            // General Tracking - count all kills and all ISK damage
            stats.totalKills++;
            // For general campaigns, put all ISK damage in the attacker field for consistency
            stats.iskDamageDoneAttacker += km.total_value || 0;
        }

        // Process ship group stats and character stats
        await Promise.all([
            processShipGroupStat(
                km,
                stats,
                shipGroupMap,
                victimOnAttackerSide,
                attackersOnAttackerSide,
                victimOnVictimSide,
                attackersOnVictimSide
            ),
            processCharacterStats(
                km,
                stats,
                characterKillsMap,
                characterLossesMap,
                characterDamageMap,
                characterDamageTakenMap,
                corporationKillsMap,
                corporationLossesMap,
                allianceKillsMap,
                allianceLossesMap,
                mostValuableKillsArray,
                campaignQuery,
                trackedKillmails,
                victimOnAttackerSide,
                attackersOnAttackerSide,
                victimOnVictimSide,
                attackersOnVictimSide
            ),
        ]);
    }
}

/**
 * Process ship group statistics for a killmail
 */
async function processShipGroupStat(
    km: IKillmail,
    stats: ICampaignOutput,
    shipGroupMap: Map<
        string,
        {
            ship_group_id: number;
            ship_group_name: string | ITranslation;
            killed: number;
            lost: number;
        }
    >,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    const victimShipGroupName = km.victim.ship_group_name || {
        en: "Unknown Ship Group",
    };
    const victimShipGroupNameKey =
        typeof victimShipGroupName === "object"
            ? victimShipGroupName.en ||
              Object.values(victimShipGroupName)[0] ||
              "Unknown Ship Group"
            : victimShipGroupName;

    let shipStat = shipGroupMap.get(victimShipGroupNameKey);
    if (!shipStat) {
        shipStat = {
            ship_group_id: km.victim.ship_group_id || 0,
            ship_group_name: victimShipGroupName,
            killed: 0,
            lost: 0,
        };
        shipGroupMap.set(victimShipGroupNameKey, shipStat);
    }

    if (stats.attackerVsVictim) {
        // Check if campaign defines any attackers or victims
        const hasAttackerDefinitions = Object.keys(stats.campaignQuery).some(
            (key) => key.startsWith("attackers.")
        );
        const hasVictimDefinitions = Object.keys(stats.campaignQuery).some(
            (key) => key.startsWith("victim.")
        );

        if (hasAttackerDefinitions && hasVictimDefinitions) {
            // Mixed Campaign: Track both directions separately

            // Step 5: Calculate ships killed by attackers vs victims
            if (attackersOnAttackerSide && victimOnVictimSide) {
                shipStat.killed++;
            }

            // Step 6: Calculate ships killed by victims vs attackers
            if (attackersOnVictimSide && victimOnAttackerSide) {
                shipStat.lost++;
            }
        } else if (hasAttackerDefinitions && !hasVictimDefinitions) {
            // Attacker-only Campaign: Only track kills by attackers
            if (attackersOnAttackerSide) {
                shipStat.killed++;
            }
            // Don't track losses for attacker-only campaigns
        } else if (hasVictimDefinitions && !hasAttackerDefinitions) {
            // Victim-only Campaign: Only track losses of victims
            if (victimOnVictimSide) {
                shipStat.lost++;
            }
            // Don't track kills for victim-only campaigns
        }
    } else {
        // General Tracking
        shipStat.killed++; // All losses are "kills" from campaign perspective
    }
}

/**
 * Process character statistics for a killmail
 */
async function processCharacterStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<
        number,
        { character_id: number; character_name: string; kills: number }
    >,
    characterLossesMap: Map<
        number,
        { character_id: number; character_name: string; losses: number }
    >,
    characterDamageMap: Map<
        number,
        { character_id: number; character_name: string; damageDone: number }
    >,
    characterDamageTakenMap: Map<
        number,
        { character_id: number; character_name: string; damageTaken: number }
    >,
    corporationKillsMap: Map<
        number,
        { corporation_id: number; corporation_name: string; kills: number }
    >,
    corporationLossesMap: Map<
        number,
        { corporation_id: number; corporation_name: string; losses: number }
    >,
    allianceKillsMap: Map<
        number,
        { alliance_id: number; alliance_name: string; kills: number }
    >,
    allianceLossesMap: Map<
        number,
        { alliance_id: number; alliance_name: string; losses: number }
    >,
    mostValuableKillsArray: Array<{
        killmail_id: number;
        total_value: number;
        victim: any;
        final_blow?: any;
    }>,
    campaignQuery: ICampaign["query"],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    // Process all statistics in parallel
    await Promise.all([
        processKillerAttribution(
            km,
            stats,
            characterKillsMap,
            campaignQuery,
            trackedKillmails,
            victimOnAttackerSide,
            attackersOnAttackerSide,
            victimOnVictimSide,
            attackersOnVictimSide
        ),
        processVictimAttribution(
            km,
            stats,
            characterLossesMap,
            campaignQuery,
            trackedKillmails,
            victimOnAttackerSide,
            attackersOnAttackerSide,
            victimOnVictimSide,
            attackersOnVictimSide
        ),
        processDamageStats(km, stats, characterDamageMap, campaignQuery),
        processDamageTakenStats(
            km,
            stats,
            characterDamageTakenMap,
            campaignQuery
        ),
        processCorporationStats(
            km,
            stats,
            corporationKillsMap,
            corporationLossesMap,
            campaignQuery,
            victimOnAttackerSide,
            attackersOnAttackerSide,
            victimOnVictimSide,
            attackersOnVictimSide
        ),
        processAllianceStats(
            km,
            stats,
            allianceKillsMap,
            allianceLossesMap,
            campaignQuery,
            victimOnAttackerSide,
            attackersOnAttackerSide,
            victimOnVictimSide,
            attackersOnVictimSide
        ),
        processMostValuableKills(km, mostValuableKillsArray),
    ]);
}

/**
 * Process killer attribution for a killmail
 */
async function processKillerAttribution(
    km: IKillmail,
    stats: ICampaignOutput,
    characterKillsMap: Map<
        number,
        { character_id: number; character_name: string; kills: number }
    >,
    campaignQuery: ICampaign["query"],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    // Check if campaign defines any attackers or victims
    const hasAttackerDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("attackers.")
    );
    const hasVictimDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("victim.")
    );

    if (stats.attackerVsVictim) {
        // For mixed campaigns (both attackers and victims defined), we track kills from both directions
        if (hasAttackerDefinitions && hasVictimDefinitions) {
            // Mixed campaign: track kills by both campaign-defined sides

            // Track kills when attackers kill victims
            if (attackersOnAttackerSide && victimOnVictimSide) {
                let finalBlowAttacker = km.attackers.find(
                    (a: any) =>
                        a.is_final_blow && isAttackerSide(a, campaignQuery)
                );

                if (!finalBlowAttacker) {
                    finalBlowAttacker = km.attackers
                        .filter((a: any) => isAttackerSide(a, campaignQuery))
                        .sort(
                            (a: any, b: any) =>
                                (b.damage_done || 0) - (a.damage_done || 0)
                        )[0];
                }

                if (finalBlowAttacker && finalBlowAttacker.character_id) {
                    let killerStat = characterKillsMap.get(
                        finalBlowAttacker.character_id
                    );
                    if (!killerStat) {
                        killerStat = {
                            character_id: finalBlowAttacker.character_id,
                            character_name:
                                finalBlowAttacker.character_name ||
                                "Unknown Character",
                            kills: 0,
                        };
                        characterKillsMap.set(
                            finalBlowAttacker.character_id,
                            killerStat
                        );
                    }
                    killerStat.kills++;
                }
            }

            // Track kills when victims kill attackers (for complete statistics)
            if (attackersOnVictimSide && victimOnAttackerSide) {
                let finalBlowAttacker = km.attackers.find(
                    (a: any) =>
                        a.is_final_blow && isVictimSide(a, campaignQuery)
                );

                if (!finalBlowAttacker) {
                    finalBlowAttacker = km.attackers
                        .filter((a: any) => isVictimSide(a, campaignQuery))
                        .sort(
                            (a: any, b: any) =>
                                (b.damage_done || 0) - (a.damage_done || 0)
                        )[0];
                }

                if (finalBlowAttacker && finalBlowAttacker.character_id) {
                    let killerStat = characterKillsMap.get(
                        finalBlowAttacker.character_id
                    );
                    if (!killerStat) {
                        killerStat = {
                            character_id: finalBlowAttacker.character_id,
                            character_name:
                                finalBlowAttacker.character_name ||
                                "Unknown Character",
                            kills: 0,
                        };
                        characterKillsMap.set(
                            finalBlowAttacker.character_id,
                            killerStat
                        );
                    }
                    killerStat.kills++;
                }
            }
        } else if (
            hasAttackerDefinitions &&
            attackersOnAttackerSide &&
            !victimOnAttackerSide
        ) {
            // Campaign-defined attackers killed a non-campaign entity
            // First try to attribute to final blow if they're on attacker side
            let finalBlowAttacker = km.attackers.find(
                (a: any) => a.is_final_blow && isAttackerSide(a, campaignQuery)
            );

            // If no final blow attacker on attacker side, find the top damage dealer on attacker side
            if (!finalBlowAttacker) {
                finalBlowAttacker = km.attackers
                    .filter((a: any) => isAttackerSide(a, campaignQuery))
                    .sort(
                        (a: any, b: any) =>
                            (b.damage_done || 0) - (a.damage_done || 0)
                    )[0];
            }

            // If we have a valid attacker to attribute the kill to
            if (finalBlowAttacker && finalBlowAttacker.character_id) {
                let killerStat = characterKillsMap.get(
                    finalBlowAttacker.character_id
                );
                if (!killerStat) {
                    killerStat = {
                        character_id: finalBlowAttacker.character_id,
                        character_name:
                            finalBlowAttacker.character_name ||
                            "Unknown Character",
                        kills: 0,
                    };
                    characterKillsMap.set(
                        finalBlowAttacker.character_id,
                        killerStat
                    );
                }

                // Only increment if we haven't counted this killmail for this character
                if (!trackedKillmails.has(km.killmail_id)) {
                    killerStat.kills++;
                    trackedKillmails.add(km.killmail_id);
                }
            }
        } else if (hasVictimDefinitions && !hasAttackerDefinitions) {
            // Victim-only campaign: track kills by NON-victims (to show top attackers against victims)
            // First try to attribute to final blow if they're NOT on victim side
            let finalBlowAttacker = km.attackers.find(
                (a: any) => a.is_final_blow && !isVictimSide(a, campaignQuery)
            );

            // If no final blow attacker from non-victims, find the top damage dealer from non-victims
            if (!finalBlowAttacker) {
                finalBlowAttacker = km.attackers
                    .filter((a: any) => !isVictimSide(a, campaignQuery))
                    .sort(
                        (a: any, b: any) =>
                            (b.damage_done || 0) - (a.damage_done || 0)
                    )[0];
            }

            // If we have a valid non-victim attacker to attribute the kill to
            if (finalBlowAttacker && finalBlowAttacker.character_id) {
                let killerStat = characterKillsMap.get(
                    finalBlowAttacker.character_id
                );
                if (!killerStat) {
                    killerStat = {
                        character_id: finalBlowAttacker.character_id,
                        character_name:
                            finalBlowAttacker.character_name ||
                            "Unknown Character",
                        kills: 0,
                    };
                    characterKillsMap.set(
                        finalBlowAttacker.character_id,
                        killerStat
                    );
                }

                // Only increment if we haven't counted this killmail for this character
                if (!trackedKillmails.has(km.killmail_id)) {
                    killerStat.kills++;
                    trackedKillmails.add(km.killmail_id);
                }
            }
        } else if (hasAttackerDefinitions && !hasVictimDefinitions) {
            // Attacker-only campaign: track losses by NON-attackers (to show top victims against attackers)
            // Only process if the victim is NOT on the attacker side
            if (
                km.victim &&
                km.victim.character_id &&
                !isAttackerSide(km.victim, campaignQuery)
            ) {
                // This victim is not part of the defined attackers, so they can be a "victim" in our stats
                // This will be handled in the processVictimAttribution function
            }
        }
    } else {
        // General tracking - attribute kill to the final blow attacker
        const finalBlowAttacker = km.attackers.find(
            (a: any) => a.is_final_blow
        );

        if (finalBlowAttacker && finalBlowAttacker.character_id) {
            let killerStat = characterKillsMap.get(
                finalBlowAttacker.character_id
            );
            if (!killerStat) {
                killerStat = {
                    character_id: finalBlowAttacker.character_id,
                    character_name:
                        finalBlowAttacker.character_name || "Unknown Character",
                    kills: 0,
                };
                characterKillsMap.set(
                    finalBlowAttacker.character_id,
                    killerStat
                );
            }

            // Only increment if we haven't counted this killmail for this character
            if (!trackedKillmails.has(km.killmail_id)) {
                killerStat.kills++;
                trackedKillmails.add(km.killmail_id);
            }
        }
    }
}

/**
 * Process victim attribution for a killmail
 */
async function processVictimAttribution(
    km: IKillmail,
    stats: ICampaignOutput,
    characterLossesMap: Map<
        number,
        { character_id: number; character_name: string; losses: number }
    >,
    campaignQuery: ICampaign["query"],
    trackedKillmails: Set<number>,
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    // Check if campaign defines any attackers or victims
    const hasAttackerDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("attackers.")
    );
    const hasVictimDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("victim.")
    );

    // Track victim character for campaign-relevant losses
    if (km.victim && km.victim.character_id) {
        let shouldTrackVictim = false;

        if (stats.attackerVsVictim) {
            // For attacker vs victim campaigns, track based on campaign definitions
            if (hasAttackerDefinitions && hasVictimDefinitions) {
                // Mixed campaign: track victims from both directions

                // 1. Track when campaign-defined victims are killed
                if (hasVictimDefinitions && victimOnVictimSide) {
                    shouldTrackVictim = true;
                }

                // 2. Track when campaign-defined attackers are killed (cross-pollination)
                if (hasAttackerDefinitions && victimOnAttackerSide) {
                    shouldTrackVictim = true;
                }
            } else if (hasVictimDefinitions && victimOnVictimSide) {
                // Campaign-defined victim was killed
                shouldTrackVictim = true;
            } else if (hasAttackerDefinitions && victimOnAttackerSide) {
                // Campaign-defined attacker was killed (attacker became victim)
                shouldTrackVictim = true;
            } else if (
                hasAttackerDefinitions &&
                !hasVictimDefinitions &&
                !victimOnAttackerSide
            ) {
                // Attacker-only campaign: track victims who are NOT part of the defined attackers
                shouldTrackVictim = true;
            }
        } else {
            // For general campaigns (location/time based), track all victims
            shouldTrackVictim = true;
        }

        if (shouldTrackVictim) {
            let victimStat = characterLossesMap.get(km.victim.character_id);
            if (!victimStat) {
                victimStat = {
                    character_id: km.victim.character_id,
                    character_name:
                        km.victim.character_name || "Unknown Character",
                    losses: 0,
                };
                characterLossesMap.set(km.victim.character_id, victimStat);
            }
            victimStat.losses++;
        }
    }
}

/**
 * Process damage statistics for a killmail
 */
async function processDamageStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterDamageMap: Map<
        number,
        { character_id: number; character_name: string; damageDone: number }
    >,
    campaignQuery: ICampaign["query"]
): Promise<void> {
    // Process all attackers in parallel for damage stats
    await Promise.all(
        km.attackers.map(async (attacker: any) => {
            if (!attacker.character_id || attacker.damage_done === 0) return;

            if (stats.attackerVsVictim) {
                // Check if campaign defines any attackers or victims
                const hasAttackerDefinitions = Object.keys(campaignQuery).some(
                    (key) => key.startsWith("attackers.")
                );
                const hasVictimDefinitions = Object.keys(campaignQuery).some(
                    (key) => key.startsWith("victim.")
                );

                // Count damage for attackers on the attacker side
                if (
                    hasAttackerDefinitions &&
                    (await isAttackerSide(attacker, campaignQuery))
                ) {
                    let damageDealerStat = characterDamageMap.get(
                        attacker.character_id
                    );
                    if (!damageDealerStat) {
                        damageDealerStat = {
                            character_id: attacker.character_id,
                            character_name:
                                attacker.character_name || "Unknown Character",
                            damageDone: 0,
                        };
                        characterDamageMap.set(
                            attacker.character_id,
                            damageDealerStat
                        );
                    }
                    damageDealerStat.damageDone += attacker.damage_done || 0;
                }

                // Count damage for victim entities ONLY if this is an attacker vs victim campaign
                // For victim-only campaigns, we don't track damage dealt by victims as "damage done"
                if (
                    hasVictimDefinitions &&
                    hasAttackerDefinitions &&
                    (await isVictimSide(attacker, campaignQuery))
                ) {
                    let damageDealerStat = characterDamageMap.get(
                        attacker.character_id
                    );
                    if (!damageDealerStat) {
                        damageDealerStat = {
                            character_id: attacker.character_id,
                            character_name:
                                attacker.character_name || "Unknown Character",
                            damageDone: 0,
                        };
                        characterDamageMap.set(
                            attacker.character_id,
                            damageDealerStat
                        );
                    }
                    damageDealerStat.damageDone += attacker.damage_done || 0;
                }
            } else {
                // General Tracking
                let damageDealerStat = characterDamageMap.get(
                    attacker.character_id
                );
                if (!damageDealerStat) {
                    damageDealerStat = {
                        character_id: attacker.character_id,
                        character_name:
                            attacker.character_name || "Unknown Character",
                        damageDone: 0,
                    };
                    characterDamageMap.set(
                        attacker.character_id,
                        damageDealerStat
                    );
                }
                damageDealerStat.damageDone += attacker.damage_done || 0;
            }
        })
    );
}

/**
 * Process damage taken statistics for a killmail
 */
async function processDamageTakenStats(
    km: IKillmail,
    stats: ICampaignOutput,
    characterDamageTakenMap: Map<
        number,
        { character_id: number; character_name: string; damageTaken: number }
    >,
    campaignQuery: ICampaign["query"]
): Promise<void> {
    // Process victim damage taken
    if (!km.victim?.character_id || !km.total_value) return;

    if (stats.attackerVsVictim) {
        // Check if campaign defines any attackers or victims
        const hasAttackerDefinitions = Object.keys(campaignQuery).some((key) =>
            key.startsWith("attackers.")
        );
        const hasVictimDefinitions = Object.keys(campaignQuery).some((key) =>
            key.startsWith("victim.")
        );

        // Track damage taken for campaign-relevant entities
        let shouldTrackDamage = false;

        if (
            hasVictimDefinitions &&
            (await isVictimSide(km.victim, campaignQuery))
        ) {
            shouldTrackDamage = true;
        } else if (
            hasAttackerDefinitions &&
            (await isAttackerSide(km.victim, campaignQuery))
        ) {
            shouldTrackDamage = true;
        }

        if (shouldTrackDamage) {
            let damageTakenStat = characterDamageTakenMap.get(
                km.victim.character_id
            );
            if (!damageTakenStat) {
                damageTakenStat = {
                    character_id: km.victim.character_id,
                    character_name:
                        km.victim.character_name || "Unknown Character",
                    damageTaken: 0,
                };
                characterDamageTakenMap.set(
                    km.victim.character_id,
                    damageTakenStat
                );
            }
            damageTakenStat.damageTaken += km.total_value;
        }
    } else {
        // General Tracking - track all damage taken
        let damageTakenStat = characterDamageTakenMap.get(
            km.victim.character_id
        );
        if (!damageTakenStat) {
            damageTakenStat = {
                character_id: km.victim.character_id,
                character_name: km.victim.character_name || "Unknown Character",
                damageTaken: 0,
            };
            characterDamageTakenMap.set(
                km.victim.character_id,
                damageTakenStat
            );
        }
        damageTakenStat.damageTaken += km.total_value;
    }
}

/**
 * Process corporation statistics for a killmail
 */
async function processCorporationStats(
    km: IKillmail,
    stats: ICampaignOutput,
    corporationKillsMap: Map<
        number,
        { corporation_id: number; corporation_name: string; kills: number }
    >,
    corporationLossesMap: Map<
        number,
        { corporation_id: number; corporation_name: string; losses: number }
    >,
    campaignQuery: ICampaign["query"],
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    const hasAttackerDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("attackers.")
    );
    const hasVictimDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("victim.")
    );

    // Track corporation losses
    if (km.victim?.corporation_id) {
        let shouldTrackLoss = false;

        if (stats.attackerVsVictim) {
            if (hasVictimDefinitions && victimOnVictimSide) {
                shouldTrackLoss = true;
            } else if (hasAttackerDefinitions && victimOnAttackerSide) {
                shouldTrackLoss = true;
            } else if (
                hasAttackerDefinitions &&
                !hasVictimDefinitions &&
                !victimOnAttackerSide
            ) {
                // Attacker-only campaign: track losses by NON-attackers
                shouldTrackLoss = true;
            }
        } else {
            shouldTrackLoss = true;
        }

        if (shouldTrackLoss) {
            let corpLossStat = corporationLossesMap.get(
                km.victim.corporation_id
            );
            if (!corpLossStat) {
                corpLossStat = {
                    corporation_id: km.victim.corporation_id,
                    corporation_name:
                        km.victim.corporation_name || "Unknown Corporation",
                    losses: 0,
                };
                corporationLossesMap.set(
                    km.victim.corporation_id,
                    corpLossStat
                );
            }
            corpLossStat.losses++;
        }
    }

    // Track corporation kills (unique corporations that participated in kills)
    if (stats.attackerVsVictim) {
        // Get unique corporations from attackers for this kill
        const attackerCorporations = new Set<number>();

        for (const attacker of km.attackers) {
            if (attacker.corporation_id) {
                let shouldTrackKill = false;

                if (
                    hasAttackerDefinitions &&
                    (await isAttackerSide(attacker, campaignQuery))
                ) {
                    shouldTrackKill = true;
                } else if (
                    hasVictimDefinitions &&
                    !hasAttackerDefinitions &&
                    !(await isVictimSide(attacker, campaignQuery))
                ) {
                    // Victim-only campaign - track kills by NON-victims (attackers against victims)
                    shouldTrackKill = true;
                } else if (
                    hasVictimDefinitions &&
                    hasAttackerDefinitions &&
                    (await isVictimSide(attacker, campaignQuery))
                ) {
                    shouldTrackKill = true;
                }

                if (shouldTrackKill) {
                    attackerCorporations.add(attacker.corporation_id);
                }
            }
        }

        // Add kills for unique corporations (each corporation only gets 1 kill per killmail)
        for (const corpId of attackerCorporations) {
            const attacker = km.attackers.find(
                (a) => a.corporation_id === corpId
            );
            if (attacker) {
                let corpKillStat = corporationKillsMap.get(corpId);
                if (!corpKillStat) {
                    corpKillStat = {
                        corporation_id: corpId,
                        corporation_name:
                            attacker.corporation_name || "Unknown Corporation",
                        kills: 0,
                    };
                    corporationKillsMap.set(corpId, corpKillStat);
                }
                corpKillStat.kills++;
            }
        }
    } else {
        // General tracking - count unique corporations per kill
        const attackerCorporations = new Set<number>();

        for (const attacker of km.attackers) {
            if (attacker.corporation_id) {
                attackerCorporations.add(attacker.corporation_id);
            }
        }

        for (const corpId of attackerCorporations) {
            const attacker = km.attackers.find(
                (a) => a.corporation_id === corpId
            );
            if (attacker) {
                let corpKillStat = corporationKillsMap.get(corpId);
                if (!corpKillStat) {
                    corpKillStat = {
                        corporation_id: corpId,
                        corporation_name:
                            attacker.corporation_name || "Unknown Corporation",
                        kills: 0,
                    };
                    corporationKillsMap.set(corpId, corpKillStat);
                }
                corpKillStat.kills++;
            }
        }
    }
}

/**
 * Process alliance statistics for a killmail
 */
async function processAllianceStats(
    km: IKillmail,
    stats: ICampaignOutput,
    allianceKillsMap: Map<
        number,
        { alliance_id: number; alliance_name: string; kills: number }
    >,
    allianceLossesMap: Map<
        number,
        { alliance_id: number; alliance_name: string; losses: number }
    >,
    campaignQuery: ICampaign["query"],
    victimOnAttackerSide: boolean,
    attackersOnAttackerSide: boolean,
    victimOnVictimSide: boolean,
    attackersOnVictimSide: boolean
): Promise<void> {
    const hasAttackerDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("attackers.")
    );
    const hasVictimDefinitions = Object.keys(campaignQuery).some((key) =>
        key.startsWith("victim.")
    );

    // Track alliance losses
    if (km.victim?.alliance_id) {
        let shouldTrackLoss = false;

        if (stats.attackerVsVictim) {
            if (hasVictimDefinitions && victimOnVictimSide) {
                shouldTrackLoss = true;
            } else if (hasAttackerDefinitions && victimOnAttackerSide) {
                shouldTrackLoss = true;
            } else if (
                hasAttackerDefinitions &&
                !hasVictimDefinitions &&
                !victimOnAttackerSide
            ) {
                // Attacker-only campaign: track losses by NON-attackers
                shouldTrackLoss = true;
            }
        } else {
            shouldTrackLoss = true;
        }

        if (shouldTrackLoss) {
            let allianceLossStat = allianceLossesMap.get(km.victim.alliance_id);
            if (!allianceLossStat) {
                allianceLossStat = {
                    alliance_id: km.victim.alliance_id,
                    alliance_name:
                        km.victim.alliance_name || "Unknown Alliance",
                    losses: 0,
                };
                allianceLossesMap.set(km.victim.alliance_id, allianceLossStat);
            }
            allianceLossStat.losses++;
        }
    }

    // Track alliance kills (unique alliances that participated in kills)
    if (stats.attackerVsVictim) {
        // Get unique alliances from attackers for this kill
        const attackerAlliances = new Set<number>();

        for (const attacker of km.attackers) {
            if (attacker.alliance_id) {
                let shouldTrackKill = false;

                if (
                    hasAttackerDefinitions &&
                    (await isAttackerSide(attacker, campaignQuery))
                ) {
                    shouldTrackKill = true;
                } else if (
                    hasVictimDefinitions &&
                    !hasAttackerDefinitions &&
                    !(await isVictimSide(attacker, campaignQuery))
                ) {
                    // Victim-only campaign - track kills by NON-victims (attackers against victims)
                    shouldTrackKill = true;
                } else if (
                    hasVictimDefinitions &&
                    hasAttackerDefinitions &&
                    (await isVictimSide(attacker, campaignQuery))
                ) {
                    shouldTrackKill = true;
                }

                if (shouldTrackKill) {
                    attackerAlliances.add(attacker.alliance_id);
                }
            }
        }

        // Add kills for unique alliances (each alliance only gets 1 kill per killmail)
        for (const allianceId of attackerAlliances) {
            const attacker = km.attackers.find(
                (a) => a.alliance_id === allianceId
            );
            if (attacker) {
                let allianceKillStat = allianceKillsMap.get(allianceId);
                if (!allianceKillStat) {
                    allianceKillStat = {
                        alliance_id: allianceId,
                        alliance_name:
                            attacker.alliance_name || "Unknown Alliance",
                        kills: 0,
                    };
                    allianceKillsMap.set(allianceId, allianceKillStat);
                }
                allianceKillStat.kills++;
            }
        }
    } else {
        // General tracking - count unique alliances per kill
        const attackerAlliances = new Set<number>();

        for (const attacker of km.attackers) {
            if (attacker.alliance_id) {
                attackerAlliances.add(attacker.alliance_id);
            }
        }

        for (const allianceId of attackerAlliances) {
            const attacker = km.attackers.find(
                (a) => a.alliance_id === allianceId
            );
            if (attacker) {
                let allianceKillStat = allianceKillsMap.get(allianceId);
                if (!allianceKillStat) {
                    allianceKillStat = {
                        alliance_id: allianceId,
                        alliance_name:
                            attacker.alliance_name || "Unknown Alliance",
                        kills: 0,
                    };
                    allianceKillsMap.set(allianceId, allianceKillStat);
                }
                allianceKillStat.kills++;
            }
        }
    }
}

/**
 * Process most valuable kills for a killmail
 */
async function processMostValuableKills(
    km: IKillmail,
    mostValuableKillsArray: Array<{
        killmail_id: number;
        total_value: number;
        victim: any;
        final_blow?: any;
    }>
): Promise<void> {
    if (!km.total_value || km.total_value === 0) return;

    // Find final blow attacker
    const finalBlowAttacker =
        km.attackers.find((a: any) => a.final_blow) || km.attackers[0];

    const mostValuableKill = {
        killmail_id: km.killmail_id,
        total_value: km.total_value,
        victim: {
            ship_id: km.victim.ship_id,
            ship_name: km.victim.ship_name,
            character_id: km.victim.character_id,
            character_name: km.victim.character_name,
            corporation_id: km.victim.corporation_id,
            corporation_name: km.victim.corporation_name,
            alliance_id: km.victim.alliance_id,
            alliance_name: km.victim.alliance_name,
        },
        final_blow: finalBlowAttacker
            ? {
                  character_id: finalBlowAttacker.character_id,
                  character_name: finalBlowAttacker.character_name,
                  ship_id: finalBlowAttacker.ship_id,
                  ship_name: finalBlowAttacker.ship_name,
              }
            : undefined,
    };

    mostValuableKillsArray.push(mostValuableKill);
}
